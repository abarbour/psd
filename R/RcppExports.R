# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Taper constraints using simple derivatives
#' @rdname ctap_simple
#' @export
#' @keywords tapers tapers-constraints
#' @param tapvec integer; the number of tapers at each frequency (can be a vector)
#' @param maxslope integer; constrain based on this maximum first difference
#' @param ... additional arguments
#' @seealso \code{\link{constrain_tapers}}, \code{\link{ctap_loess}}
#' @examples
#' 
#' # generate some random taper series and constrain them based on slopes
#' set.seed(1237)
#' n <- 11
#' x <- seq_len(n)
#' xn <- round(runif(n,1,n))
#' 
#' xnf <- ctap_simple_rcpp(xn, 0) # flattens out
#' xnc <- ctap_simple_rcpp(xn, 1) # no change, already only slopes = 1
#' try(all.equal(xnc, xn))
#' xnc2 <- ctap_simple_rcpp(xn, 2) # slopes = 2 only
#'
#' plot(xn, type='b', pch=16, ylim=c(0,12))
#' grid()
#' abline(a=0,b=1, col='red', lty=3); abline(a=0,b=2, col='blue', lty=3)
#' lines(xnf, type='b', col='green')
#' lines(xnc, type='b', col='red')
#' lines(xnc2, type='b', col='blue')
#' lines(0.2+as.vector(psd::ctap_simple(psd::as.tapers(xn))), type='b', pch=".", col='salmon')
#'
#' # compare simple and rcpp implementations
#' kcr <- ctap_simple_rcpp(xn, 2)
#' kcs <- ctap_simple(xn, 2)
#' rbind(kcs, kcr)
#' try(all.equal(kcr, kcs))
#'
#' # more examples:
#' 
ctap_simple_rcpp.default <- function(tapvec, maxslope = 1L) {
    .Call('psd_ctap_simple_rcpp', PACKAGE = 'psd', tapvec, maxslope)
}

test_sample_indices <- function(x) {
    .Call('psd_test_sample_indices', PACKAGE = 'psd', x)
}

#' @title Nearest value below
#' @export
#' @description 
#' Returns the nearest \code{m}-length
#' value (downwards from \code{n}), which is different from \code{\link{nextn}}.
#' For example:
#' \code{10} is the result for \code{n=11,m=2} whereas \code{\link{nextn}} would give \code{12}
#' @param n integer; the number of terms (can be a vector)
#' @param m integer; the modulo term (cannot be zero)
#' @author A.J. Barbour <andy.barbour@@gmail.com>
#' @seealso \code{\link{psd-utilities}} and \code{\link{psdcore}}, 
#' which truncates to the nearest even length (so, \code{m=2})
#' @examples
#' n <- 11
#' nextn(n) # 12
#' modulo_floor(n) # 10
#' 
#' # works on vectors too:
#' # defaults to m=2
#' modulo_floor(seq_len(n))
#' #[1]  0  2  2  4  4  6  6  8  8 10 10
#' 
#' # change the floor factor
#' modulo_floor(seq_len(n), 3)
#' #[1] 0 0 3 3 3 6 6 6 9 9 9
#' 
#' # zeros are not allowed for m
#' try(modulo_floor(n, 0))
#' 
modulo_floor <- function(n, m = 2L) {
    .Call('psd_modulo_floor', PACKAGE = 'psd', n, m)
}

#' @rdname parabolic_weights
#' @export
parabolic_weights_rcpp <- function(ntap = 1L) {
    .Call('psd_parabolic_weights_rcpp', PACKAGE = 'psd', ntap)
}

#' @title Resample an fft using varying tapers
#' @param fftz complex; a vector representing the dual-length \code{\link{fft}}; see also the \code{dbl} argument
#' @param tapers integer; a vector of tapers
#' @param verbose logical; should messages be given?
#' @param dbl logical; should the code assume \code{fftz} is dual-length or singl-length?
#' @param tapcap integer; the maximum number of tapers which can be applied; note that the length is
#' automatically limited by the length of the series.
#' @examples
#' fftz <- complex(real=1:8, imaginary = 1:8)
#' taps <- 1:4
#' try(resample_fft_rcpp(fftz, taps))
#' 
#' @export
resample_fft_rcpp <- function(fftz, tapers, verbose = TRUE, dbl = TRUE, tapcap = 1000L) {
    .Call('psd_resample_fft_rcpp', PACKAGE = 'psd', fftz, tapers, verbose, dbl, tapcap)
}


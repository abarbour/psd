\documentclass[12pt]{article}\usepackage{graphicx, color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\definecolor{fgcolor}{rgb}{0.2, 0.2, 0.2}
\newcommand{\hlnumber}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlfunctioncall}[1]{\textcolor[rgb]{0.501960784313725,0,0.329411764705882}{\textbf{#1}}}%
\newcommand{\hlstring}[1]{\textcolor[rgb]{0.6,0.6,1}{#1}}%
\newcommand{\hlkeyword}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlargument}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlcomment}[1]{\textcolor[rgb]{0.180392156862745,0.6,0.341176470588235}{#1}}%
\newcommand{\hlroxygencomment}[1]{\textcolor[rgb]{0.43921568627451,0.47843137254902,0.701960784313725}{#1}}%
\newcommand{\hlformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlassignement}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlpackage}[1]{\textcolor[rgb]{0.588235294117647,0.709803921568627,0.145098039215686}{#1}}%
\newcommand{\hlslot}[1]{\textit{#1}}%
\newcommand{\hlsymbol}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlprompt}[1]{\textcolor[rgb]{0.2,0.2,0.2}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
% !Rnw weave = knitr
% sweave fig help:
% http://users.stat.umn.edu/~geyer/Sweave/foo.pdf
% borrowing design from roxygen -- AJB Jan 13

%% \VignetteIndexEntry{Normalization of power spectral densities.}
%% \VignetteEngine{knitr}

\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{natbib}
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=5cm,lmargin=2.5cm,rmargin=2.5cm}
%captions
\usepackage[font=sf, labelfont={sf,bf}, margin=2cm]{caption}
%
\usepackage{makeidx} % for indexing
\makeindex % comment to have no index
%%
\input{mathsyms}
%%
\newcommand{\SC}[1]{\textsc{#1}}
\newcommand{\SCY}[0]{\SC{Yes}}
\newcommand{\SCN}[0]{\SC{No}}
\newcommand{\Rcmd}[1]{\texttt{#1}}
\newcommand{\rlp}[0]{\Rcmd{rlpSpec}}
\newcommand{\naive}[0]{na\"{\i}ve}
\newcommand{\bidx}[1]{\index{#1}{\textbf{#1}}} 
\newcommand{\idx}[1]{\index{#1}{#1}} 
%% path, filename, caption, label
\newcommand{\listing}[4]{        %
  \begin{figure}[H]              %
    \centering                   %
    \VerbatimInput[numbers=left, %
      frame=single,              %
      label=#2]{#1}              %
    \caption{#3}                 %
    \label{#4}                   %
  \end{figure}                   %
}
\author{Andrew J. Barbour}
\title{Normalization of Power Spectral Densities.}
\begin{document}
\maketitle
\begin{abstract}
  A vast and deep pool of
  literature exists on the subject of spectral 
  analysis; wading through it can
  obscure even the most
  fundamental concepts
  to the inexperienced practitioner.
  Appropriate interpretation of spectral analyses
  depends crucially on the normalization used, and
  here we outline
  the normalization used by \rlp{}, namely
  the \bidx{single-sided}
  \bidx{power spectral density} (PSD).
  We briefly outline the background mathematics,
  present an example from scratch,
  and compare the results with
  the normalization used by 
  the spectrum estimator included in the base distribution of
  R: \Rcmd{stats::spectrum}.
\end{abstract}
\tableofcontents
%%
%%
%%
\section{Background}

There can often be confusion about the different quantities used
in spectral analysis\footnote{
A nice illustration of the type of
confusion common in spectral analyses
of confusion is found in
this thread on \Rcmd{R-help}:\\
\url{http://r.789695.n4.nabble.com/Re-How-do-I-normalize-a-PSD-td792902.html}
},
partly due to myriad nomenclature within the incredibly vast literature
on the subject.
Commonly one finds similarly sounding phrases, including ``amplitude spectrum",
``energy spectral density", ``power", ``power spectra", and even ``spectra".
These all mean \emph{something}, but are rarely equivalent, and can be used improperly.

To clarify these terms, we will walk through some background and
definitions, without overly complicating the discussion with proofs.
Let us first define a single realization
of a stochastic process in the time domain, 
\dXstoch{}, sampled over a finite interval of time
$(-T/2, \,T/2)$, denoted by \dXrealiz{}.
A realization of \dXstoch{} will have
an ordinary 
Fourier transform:
%
\begin{equation}
\Xfo_T (f) = \Fo \{ \dXrealiz{} \} = 
\intone \dXrealiz{} e^{-2 \pi i ft} \, dt = 
\int_{-T/2}^{T/2}  \dXstoch{} e^{-2 \pi i ft} \, dt
\end{equation}
%
The \bidx{amplitude spectrum} is the modulus
of $\Xfo_T$ and the
\bidx{phase spectrum} is the argument 
of $\Xfo_T$, although these are generally not informative
for physical applications, if ever.
The \bidx{energy spectral density} is found from
$\Xfo_T$ by finding the expectation of the
squared magnitude:
\begin{equation}
\dESD{} = \Ex \{ | \Xfo_T (f) | ^ 2 \}
\end{equation}

There is a problem though, in that as $T$ grows to infinity, 
so too does \dESD{}.
We divide it by the interval length $T$ to tame such growth,
which gives us an expression for
\bidx{power spectral density}:
%
\begin{equation}
\label{eq-psddef1}
\begin{split}
\dS{} & = \lim_{T \to \infty} \dESD{}/T \\
& = \lim_{T \to \infty} \Ex \left\{ \frac{1}{T} \left | 
\int_{-T/2}^{T/2}  \dXstoch{} e^{-2 \pi i ft} \, dt \right | ^ 2 \right\}
\end{split}
\end{equation}
\label{sy-psd}
which is real, non-negative, and exists for all
stationary processes \dXstoch{} with zero mean and finite variance.

Here is an important point to note regarding normalization.
Equation (\ref{eq-psddef1}) defines
the \bidx{double-sided} PSD,
because in it $f$ runs from $\pm\infty$.
If \dXstoch{} is real the power spectrum \dS{} is even; hence,
we only need estimates for $f \ge 0$.
The \bidx{single-sided} PSD is thus given by $2 S(f)$ for $f \ge 0$.
In many cases this sidedness distinction, as we will see, explains
errant factors of two in PSD normalizations.

\subsection{Connection to the autocovariance function}
What is the connection between the PSD, defined in Equation (\ref{eq-psddef1}),
and the autocovariance function \dACV{\tau}?

From Equation (\ref{eq-psddef1}) we see that \dS{}
is obtained from products of \dXstoch{} with itself at any particular $f$,
so it is related to the second-order moment of \dXstoch{} only; so too does 
the autocovariance \dACV{\tau}.
It may be surprising to note as well that \dS{} is
simply the Fourier transform of \dACV{\tau}:
%
\begin{equation}
\label{eq-psddef2}
\dS{} = \Fo \{ \dACV{t} \} =
\intone \dACV{t} e ^ {-2 \pi i ft} \, dt
\end{equation}
%
So, the
functions \dACV{\tau} and \dS{}
can contain the same information.
For real data, \dACV{\tau} is always even, and always real.
This implies that \dS{} is also a real and even function in $f$,
which, because $S(f) >= 0$, restricts the functions \dACV{t}
could possibly represent.
Put another way, there are many examples of even functions
having non-positive Fourier transforms (see \citet{bracewell2000}).

%Table with equivalent expressions
%\input{tbl_norms}

\subsection{Testing normalization}
We can use a property of the autocovariance function \dACV{\tau}
to test whether or not a PSD is properly normalized.  To see this, we
take the
inverse Fourier transform of Equation (\ref{eq-psddef2}):
%
\begin{equation}
\label{eq-psdinv}
\dACV{t} = \intone \dS{} e ^ {2 \pi i ft} \, df
\end{equation}
%
and recall a property of the autocovariance of a zero-mean 
process for zero lag:
%
\begin{equation}
\label{eq-acvprop}
\dACV{0} = \Ex \{ \dXstoch{} \dXstoch{} \} = \Var \{ \dXstoch{} \} = \sigma ^ 2
\end{equation}
%
Using (\ref{eq-acvprop}) and setting $t = 0$ in
(\ref{eq-psddef2}) gives the basis of our normalization test:
%
\begin{equation}
\label{eq-psdnorm}
\sigma ^ 2 = \intone S (f) \, df
\end{equation}
%
That is,
the area under the power spectrum is the variance
of the process.
So, a straightforward way to test normalization 
is to compute the PSD for a realization of \dXstoch{} with
known variance and zero mean [e.g. $\mathcal{N}(0,\sigma^2)$], and 
calculate the integrated spectrum.
For example, the \idx{single-sided}
PSD for a realization of a $\mathcal{N}(0, 1)$ process, 
sampled at 1 Hz, 
will be flat at 2 units$^2/$Hz 
across the entire band $[0, \half]$,
and will have
an area equal to one.

%%
%%
%%
\section{A from-scratch example: White noise.}
First, generate a series, and then find its Discrete Fourier Transform 
(DFT)\footnote{
A proper DFT is normalized by the length of the series; however, most
DFT calculators (including \Rcmd{stats::fft}) eschew this normalization for 
efficiency's sake.
}.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{set.seed}(1234)
N <- 256
x <- \hlfunctioncall{rnorm}(N, mean = 0, sd = 1)
xv <- \hlfunctioncall{var}(x)
X <- \hlfunctioncall{fft}(x)
\hlfunctioncall{class}(X)
\end{alltt}
\begin{verbatim}
## [1] "complex"
\end{verbatim}
\begin{alltt}
\hlfunctioncall{length}(X)
\end{alltt}
\begin{verbatim}
## [1] 256
\end{verbatim}
\end{kframe}
\end{knitrout}


We can easily find the amplitude and phase response:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
Sa <- \hlfunctioncall{Mod}(X)  \hlcomment{# Amplitude spectrum}
Sp <- \hlfunctioncall{Arg}(X)  \hlcomment{# Phase spectrum}
\end{alltt}
\end{kframe}
\end{knitrout}

followed by equivalent \idx{energy spectral density}
calculations\footnote{
Note the equivalence
between the complex conjugate based estimates.
}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
XC <- \hlfunctioncall{Conj}(X)
\hlfunctioncall{all.equal}(Se <- Sa^2, Se_2 <- \hlfunctioncall{Mod}(XC * X), Se_2R <- \hlfunctioncall{Mod}(X * XC))
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}


The single-sided \idx{power spectral density} (PSD) estimates
follow once the Nyquist frequency is set; this
is defined as half the sampling rate\footnote{
Although a white noise process is not strictly bandlimited,
we will use it to demonstrate differences in normalization.
}.
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
fsamp <- 1  \hlcomment{# sampling freq, Hz}
fNyq <- fsamp/2  \hlcomment{# nyquist}
Nf <- N/2
nyfreqs <- \hlfunctioncall{seq.int}(from = 0, to = fNyq, length.out = Nf)
S <- Se[1:Nf] * 2/N  \hlcomment{# Finally, the PSD!}
\hlfunctioncall{print}(\hlfunctioncall{c}(mSn <- \hlfunctioncall{mean}(S), mSm <- \hlfunctioncall{median}(S)))
\end{alltt}
\begin{verbatim}
## [1] 2.034 1.242
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{figure}[htb!]
\begin{center}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}
\includegraphics[width=\maxwidth]{figure/PSD} 

\end{knitrout}

\caption{Power spectral density estimates for a single realization of a 
$\mathcal{N}(0,1)$ process, in linear units.  
The dashed line shows the mean spectral level and the dotted line
shows the median spectral level; these can be
used to find the integrated spectrum and test normalization.}
\label{fig:psdN}
\end{center}
\end{figure}

An estimate of the integrated spectrum
should roughly equal the known variance.
Figure \ref{fig:psdN} plots the PSD of our white noise series and the 
mean and median values\footnote{
Estimates for the PSD of a white noise series
are approximately log-normally distributed; hence,
a simple mean value tends to be highly biased estimator of expectation.
}, from which we can perform a variance--normalization
test:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
test_norm <- \hlfunctioncall{function}(sval, nyq, xvar) \{
    svar <- sval * nyq
    \hlfunctioncall{return}(svar/xvar)
\}
\hlfunctioncall{print}(xv_1 <- \hlfunctioncall{test_norm}(mSn, fNyq, xv))
\end{alltt}
\begin{verbatim}
## [1] 0.9933
\end{verbatim}
\begin{alltt}
xv_2 <- \hlfunctioncall{sum}(S)/Nf * fNyq/xv  \hlcomment{# an alternate test}
\hlfunctioncall{all.equal}(xv_1, xv_2)
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}


But what if the sampling frequency \texttt{fsamp} changes? An obvious change will be
the actual Nyquist frequency, which means the variance--normalization test will
fail if the PSD estimates are not re-scaled.  We simply re-scale the frequencies
and PSD
with the sampling rate
to obtain the properly-normalized spectra.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
fsamp <- 20
fNyq <- fsamp/2
freqs <- fsamp * nyfreqs
Snew <- S/fsamp
\hlcomment{# Test variance crudely}
mSn <- \hlfunctioncall{mean}(Snew)
\hlfunctioncall{test_norm}(mSn, fNyq, xv)
\end{alltt}
\begin{verbatim}
## [1] 0.9933
\end{verbatim}
\end{kframe}
\end{knitrout}


In Figure \ref{fig:psdsamp} we
plot the PSD with new normalization, and compare it to
the previous normalization.
Spectral values are shown as
decibels (relative to 1 units$^2/$frequency), using:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# decibel function}
dB <- \hlfunctioncall{function}(y) 10 * \hlfunctioncall{log10}(y)
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[htb!]
\begin{center}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}
\includegraphics[width=\maxwidth]{figure/PSD2} 

\end{knitrout}

\caption{Rescaled PSD estimates for a single realization of a 
$\mathcal{N}(0,1)$ process with a sampling rate of 20 s$^{-1}$ rather
than 1 s$^{-1}$ as from before.  
The thick red line shows the mean (rescaled) spectral level, and the
blue line shows the predicted mean value based on twice the sampling
frequency.}
\label{fig:psdsamp}
\end{center}
\end{figure}

\section{Normalization used in \Rcmd{stats::spectrum}}

The PSD estimator included in
the core distribution of R is \Rcmd{stats::spectrum}, which
calls either \Rcmd{stats::spec.ar} or \Rcmd{stats::spec.pgram} for 
cases of
parametric and non-parametric estimation, respectively.  
For this discussion we compare to \Rcmd{spec.pgram};
the user can, optionally, apply a single cosine taper, 
and/or a smoothing kernel.

By default \Rcmd{spec.pgram} assumes the sampling frequency
for the input series is 1, and normalizes accordingly; however,
the sampling information may be specified by creating a \Rcmd{ts}
object from the series prior to spectrum estimation:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
fsamp <- 20
xt <- \hlfunctioncall{ts}(x, frequency = fsamp)
pgram20 <- \hlfunctioncall{spec.pgram}(xt, pad = 1, taper = 0, plot = FALSE)
pgram01 <- \hlfunctioncall{spec.pgram}(\hlfunctioncall{ts}(xt, frequency = 1), pad = 1, taper = 0, plot = FALSE)
\end{alltt}
\end{kframe}
\end{knitrout}


We plot the two PSD estimates on the same scales, in Figure \ref{fig:rawpgram}, utilizing
the plot method for \Rcmd{spec} objects: \Rcmd{plot.spec}.
We also show horizontal lines corresponding to the inverse of twice
the sampling rate, which puts the spectra about a factor of 2 too low:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
mSn/\hlfunctioncall{mean}(pgram20$spec)
\end{alltt}
\begin{verbatim}
## [1] 2.05
\end{verbatim}
\end{kframe}
\end{knitrout}

%## [1] 2.05

\begin{figure}[h!]
\begin{center}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}
\includegraphics[width=\maxwidth]{figure/NORMS} 

\end{knitrout}


\caption{Power spectral densities from \Rcmd{spec.pgram} for the same
data series.  The grey curves show the PSD for a sampling rate of 1; whereas,
the black curves show the PSD for a sampling rate of 20.
The horizontal lines show levels corresponding to the inverse of
twice the sampling rate (black and grey), and 
the expected spectral level for the 20 Hz sampling in blue.
Vertical lines show the respective Nyquist frequencies.}
\label{fig:rawpgram}
\end{center}
\end{figure}

Because the frequencies are clearly correct, this factor of two likely means
the spectra will fail our
simple variance-normalization test. They do fail, by a factor of two,
again too low:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlfunctioncall{test_norm}(\hlfunctioncall{mean}(pgram01$spec), 0.5, xv)
\end{alltt}
\begin{verbatim}
## [1] 0.4845
\end{verbatim}
\begin{alltt}
\hlfunctioncall{test_norm}(\hlfunctioncall{mean}(pgram20$spec), 10, xv)
\end{alltt}
\begin{verbatim}
## [1] 0.4845
\end{verbatim}
\end{kframe}
\end{knitrout}


But why?  This errant factor of two comes from
the assumption of a
\idx{double-sided} spectrum, which 
is at odds with our definition of the 
\idx{single-sided} spectrum
by--you guessed it--a factor of two.
We can illustrate this with the following example, where
we compare the PSDs from \Rcmd{spec.pgram} for a real
and complex series:

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
psd1 <- \hlfunctioncall{spec.pgram}(x, plot = FALSE)
psd2 <- \hlfunctioncall{spec.pgram}(xc <- \hlfunctioncall{complex}(real = x, imag = x), plot = FALSE, demean = TRUE)
mx <- \hlfunctioncall{mean}(\hlfunctioncall{Mod}(x))
mxc <- \hlfunctioncall{mean}(\hlfunctioncall{Mod}(xc))
(mxc/mx)^2
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\begin{alltt}
\hlfunctioncall{mean}(psd2$spec/psd1$spec)
\end{alltt}
\begin{verbatim}
## [1] 2
\end{verbatim}
\end{kframe}
\end{knitrout}


Again, a factor of two. 
This means that unless we are interested in analyzing complex
timeseries, we need only multiply by two 
to obtain properly normalized spectra
from \Rcmd{spectrum}, 
assuming the sampling information is included in the series.

\section{Other PSD estimators}
The suite of extensions having
similar functionality to \rlp{}
is relatively limited; however, there are at least three which
can produce sophisticated PSD estimates.   We have
summarized the available functions in Table \ref{tbl:methods}
so far as we know\footnote{
As of this writing (Feb 2013), \Rcmd{sapa} appears to be orphaned.
}.

\input{tbl_specprogs}

%% bib
\pagebreak
\bibliographystyle{apalike}
\bibliography{REFS}

\printindex
\end{document}

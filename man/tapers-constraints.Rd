% Generated by roxygen2 (4.0.2): do not edit by hand
\name{ctap_simple_rcpp.default}
\alias{constrain_tapers}
\alias{constrain_tapers.tapers}
\alias{ctap_friedman}
\alias{ctap_loess}
\alias{ctap_loess.tapers}
\alias{ctap_markov}
\alias{ctap_simple}
\alias{ctap_simple.tapers}
\alias{ctap_simple_rcpp}
\alias{ctap_simple_rcpp.default}
\alias{ctap_simple_rcpp.tapers}
\alias{minspan}
\alias{minspan.tapers}
\alias{tapers-constraints}
\title{Taper constraint methods.}
\usage{
\method{ctap_simple_rcpp}{default}(tapvec, maxslope = 1L)

minspan(tapvec, ...)

\method{minspan}{tapers}(tapvec, ...)

constrain_tapers(tapvec, ...)

\method{constrain_tapers}{tapers}(tapvec, tapseq = NULL,
  constraint.method = c("simple.slope.rcpp", "simple.slope", "loess.smooth",
  "none"), verbose = TRUE, ...)

ctap_simple_rcpp(tapvec, ...)

\method{ctap_simple_rcpp}{tapers}(tapvec, tapseq = NA, maxslope = 1, ...)

ctap_simple(tapvec, ...)

\method{ctap_simple}{tapers}(tapvec, tapseq = NA, maxslope = 1, ...)

ctap_loess(tapvec, ...)

\method{ctap_loess}{tapers}(tapvec, tapseq = NULL, loess.span = 0.3,
  loess.degree = 1, verbose = TRUE, ...)

ctap_markov()

ctap_friedman()
}
\arguments{
\item{tapvec}{\code{'tapers'} object; the number of tapers at each frequency}

\item{maxslope}{integer; constrain based on this maximum first difference}

\item{...}{optional arguments (unused)}

\item{tapseq}{vector; positions or frequencies -- necessary for smoother methods}

\item{constraint.method}{character; method to use for constraints on tapers numbers}

\item{verbose}{logical; should warnings and messages be given?}

\item{loess.span}{scalar; the span used in \code{loess}}

\item{loess.degree}{scalar; the polynomial degree}
}
\value{
An object with class \code{'tapers'}.
}
\description{
In the Riedel-Sidorenko recipe, the number of optimal tapers
at each frequency is strongly dependent on the first and
second derivatives of the spectrum. It is crucial to enforce
constraints on the number of actual tapers applied; this is
because the derivatives of "noisy" series can be bogus.

\code{\link{minspan}} sets the maximum span a tapers object
may have, which is necessary because it would be nonsense to
have more tapers than the length of the series.

\code{\link{constrain_tapers}} refines the number of tapers;
the method by which it does this is chosen with the \code{constraint.method}
parameter. See \strong{Constraint methods} section for descriptions of each method.
Below is a summary of the function associated with each \code{constraint.method}:
\itemize{
  \item \code{'simple.slope.rcpp'} uses \code{\link{ctap_simple_rcpp}}
  \item \code{'simple.slope'} uses \code{\link{ctap_simple}}
  \item \code{'loess.smooth'} uses \code{\link{ctap_loess}}
  \item \code{'none'} returns unbounded tapers.
}
}
\details{
\code{\link{minspan}} bounds the number of tapers to within
the minimum of
either the maximum number of tapers found in the object,
or the half-length of the series.
}
\section{Details of Constraint Methods}{


\subsection{via first differencing (the default)}{

\code{\link{ctap_simple_rcpp}} is the preferred constraint method
(in previous versions \code{\link{ctap_simple}} was).
The algorithm uses first-differencing to modify the number
of tapers in the previous position.  Effectively, the constraint
is based on a causal, 1st-order Finite Impulse-response Filter (FIR)
which makes the method
sensitive to rapid changes in the number of tapers; naturally,
smoother spectra tend to produce less fluctuation in taper numbers,
which makes this well suited for adaptive processing.

This produces, generally, the most
stable results, meaning repeatedly running the constraint will not change values
other than on the first execution; the same cannot be said for the other
methods, which are also considerably more expensive to use.

}

\subsection{via LOESS smoothing}{
\code{\link{ctap_loess}} uses \code{loess} to smooth the taper vector; is
can be very slow thanks to quadratic scaling.
}
}

\section{Warning}{


\code{\link{ctap_loess}} results tend to be strongly dependent on
the tuning parameters given to \code{loess} (for obvious reasons); hence,
some effort should be given to understand
their effect, and/or re-tuning them if needed.
}
\examples{
# generate some random taper series and constrain them based on slopes
set.seed(1237)
n <- 11
x <- seq_len(n)
xn <- round(runif(n,1,n))

xnf <- ctap_simple_rcpp(xn, 0) # flattens out
xnc <- ctap_simple_rcpp(xn, 1) # no change, already only slopes = 1
try(all.equal(xnc, xn))
xnc2 <- ctap_simple_rcpp(xn, 2) # slopes = 2 only

plot(xn, type='b', pch=16, ylim=c(0,12))
grid()
abline(a=0,b=1, col='red', lty=3); abline(a=0,b=2, col='blue', lty=3)
lines(xnf, type='b', col='green')
lines(xnc, type='b', col='red')
lines(xnc2, type='b', col='blue')
lines(0.2+as.vector(psd::ctap_simple(psd::as.tapers(xn))), type='b', pch=".", col='salmon')

# more examples:
\dontrun{#REX
library(psd)
##
## Taper constraint procedures
##
data(magnet)
X <- magnet$clean
##
## spectrum, then riedsid
kopt <- riedsid(PSD <- psdcore(X, ntaper=10, refresh=TRUE))
kopt.loess  <- riedsid(PSD, c.method="loess.smooth")
#
plot(kopt, log="y", ylim =c(.1, 3e2))
lines(kopt.loess, log="y", col="green")
##
##
## To compare all the methods at once:
demo("ctap")
##
}#REX
}
\author{
A.J. Barbour <andy.barbour@gmail.com> and R.L.Parker.
AJB adapted some of RLP's original code,
and wrote the main function in \code{\link{ctap_simple}} for dynamic loading C-code.
}
\seealso{
\code{\link{as.tapers}} and \code{\link{constrain_tapers}}
}
\keyword{tapers}
\keyword{tapers-constraints}


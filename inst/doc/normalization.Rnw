\documentclass[12pt]{article}
% sweave fig help:
% http://users.stat.umn.edu/~geyer/Sweave/foo.pdf
% borrowing design from roxygen -- AJB Jan 13
%% \VignetteIndexEntry{rlpSpec Normalization Vignette}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{amssymb}
\usepackage{float}
\usepackage{natbib}
\usepackage{fullpage}
\usepackage{makeidx} % for indexing
\usepackage{showidx} % shows page (remove when complete)
\makeindex % comment to have no index
%%
\include{symdefs}
%%
\newcommand{\SC}[1]{\textsc{#1}}
\newcommand{\SCY}[0]{\SC{Yes}}
\newcommand{\SCN}[0]{\SC{No}}
\newcommand{\Rcmd}[1]{\texttt{#1}}
\newcommand{\rlp}[0]{\Rcmd{rlpSpec}}
\newcommand{\naive}[0]{na\"{\i}ve}
\newcommand{\bidx}[1]{\index{#1}{\textbf{#1}}} 
\newcommand{\idx}[1]{\index{#1}{#1}} 
%% path, filename, caption, label
\newcommand{\listing}[4]{        %
  \begin{figure}[H]              %
    \centering                   %
    \VerbatimInput[numbers=left, %
      frame=single,              %
      label=#2]{#1}              %
    \caption{#3}                 %
    \label{#4}                   %
  \end{figure}                   %
}
\author{Andrew J. Barbour}
\title{Normalization used in \rlp{}}
\begin{document}
\maketitle
\begin{abstract}
  A vast and deep pool of
  literature exists on the subject of spectral 
  analysis; wading through it can
  obscure even the most
  fundamental concepts
  to the inexperienced practitioner.
  Appropriate interpretation of spectral analyses
  depends crucially on the normalization used, and
  here we outline
  the normalization used by \rlp{}, namely
  \bidx{power spectral density} (PSD).
  We compare the PSD to other quantities 
  commonly encountered in spectral analysis research, as
  well as normalizations used in a subset of 
  the current suite of spectral analysis tools available in R.
\end{abstract}
\tableofcontents
\section{Background}
There can often be confusion about the different quantities used
in spectral analysis\footnote{
A nice illustration of the type of
confusion common in spectral analyses
of confusion is found in
this thread on \Rcmd{R-help}:\\
\url{http://r.789695.n4.nabble.com/Re-How-do-I-normalize-a-PSD-td792902.html}
},
partly due to myriad nomenclature within the incredibly vast literature
on the subject.
Commonly one finds similarly sounding phrases, including ``amplitude spectrum",
``energy spectral density", ``power", ``power spectra", and even "spectra".
These all mean \emph{something}, but are rarely equivalent, and can be used improperly.

Let us, for the sake of brevity, assume we are in 
the time domain, and we are considering a discrete stationary signal \df{}
of length $N$,
having a Discrete Fourier Transform \dFTp{f} represented by\dF{}.
The \bidx{amplitude spectrum}
of this transform pair is simply the 
amplitude of \dF{}, or \dmodF{}, which we will denote this as \daS{}.
This transform pair's corresponding \bidx{phase spectrum}
is the phase angle of \dF{}, or \dargF{}, denoted by \dpS{}.

How do we interpret the quantities 

Table with equivalent expressions
\input{tbl_norms}

\section{A from-scratch example: White noise.}
A straightforward way to understand normalization in spectral analysis
is to analyze a real, stationary series which is normally distributed with
known variance, $x=\mathcal{N}(\mu,\sigma^2)$.
A fundamental result found in many texts on spectral analysis is
%
\begin{equation}
\mathrm{var}\{x\} \equiv \sigma_x^2 
= \int_{-1/2}^{1/2} {\dPSD{}} (f) df 
= 2 \int_{0}^{1/2} {\dPSD{}} (f) df 
\end{equation}
%
which says if we integrate the \idx{power spectral density}
over all frequencies we can obtain the variance of the source process.
If we have a $\mathcal{N}(0, 1)$ process, and assume the sampling
interval is once per second, we should expect a
 flat spectrum of 2 units$^2/$Nyquist 
across all frequencies $[0, 0.5]$ so that the area under the spectrum is
equal to one.

We can illustrate this with a few lines of code.
First, generate a series, and then find its iscrete Fourier Transform (DFT)\footnote{
A proper DFT is normalized by the length of the series; however, most
DFT calculators (including \Rcmd{stats::fft}) eschew this normalization for 
efficiency's sake.
}.
<<eval=TRUE, echo=TRUE>>=
set.seed(1234)
N <- 256
x <- rnorm(N, mean = 0, sd = 1)
xv <- var(x)
X <- fft(x)
class(X)
length(X)
@

We can easily find the amplitude and phase response:
<<eval=TRUE, echo=TRUE>>=
Sa <- Mod(X) # Amplitude spectrum
Sp <- Arg(X) # Phase spectrum
@
followed by equivalent \idx{energy spectral density}
calculations\footnote{
Note the equivalence
between the complex conjugate based estimates.
}
<<eval=TRUE, echo=TRUE>>=
XC <- Conj(X)
all.equal(Se <- Sa**2, Se_2 <- Mod(XC * X), Se_2R <- Mod(X * XC))
@

The single-sided \idx{power spectral density} (PSD) estimates
follow once the Nyquist frequency is set; this
is defined as half the sampling rate\footnote{
Although a white noise process is not strictly bandlimited,
we will use it to demonstrate differences in normalization.
}.
<<eval=TRUE, echo=TRUE>>=
fsamp <- 1  # sampling freq, Hz
fNyq <- fsamp/2   # nyquist
Nf <- N/2
nyfreqs <- seq.int(from=0, to=fNyq, length.out=Nf)
S <- Se[1:Nf] * 2 / N   # Finally, the PSD!
@

\begin{figure}[htb!]
\begin{center}
<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=PSD>>=
plot(nyfreqs, S, type="h", xlab="Nyquist frequency", ylab="units**2 / freq")
print(c(mSn <- mean(S), mSm <- median(S)))
abline(h=c(mSn,mSm), lwd=2, lty=c(2,3), col="red")
@
%polygon(c(0,fNyq,fNyq,0,0), c(0,0,mSn,mSn,0), lwd=2, lty=2, border="red")
\label{fig:psdN}
\caption{Power spectral density estimates for a single realization of a 
$\mathcal{N}(0,1)$ process in linear units.  
The dashed line shows the mean spectral level and the dotted line
shows the median spectral level; these can be
used to find the integrated spectrum and test normalization.}
\end{center}
\end{figure}

An estimate of the integrated spectrum
should roughly equal the known variance.
Figure \ref{fig:psdN} plots the PSD of our white noise series; it also shows
the mean value of the PSD\footnote{
Estimates for the PSD of a white noise series
are approximately log-normally distributed; hence,
a simple mean value is highly biased estimator.
}, from which we can perform a variance--normalization
test:
<<eval=TRUE, echo=TRUE>>=
test_norm <- function(sval, nyq, xvar){svar <- sval * nyq; return(svar/xvar)}
print(xv_1 <- test_norm(mSn, fNyq, xv))
xv_2 <- sum(S)/Nf * fNyq / xv  # an alternate test
all.equal(xv_1, xv_2)
@

But what if the sampling frequency \texttt{fsamp} changes? An obvious change will be
the actual Nyquist frequency, which means the variance--normalization test will
fail if the PSD estimates are not re-scaled.  We simply re-scale the frequencies
and PSD
with the sampling rate
to obtain the properly-normalized spectra.

<<eval=TRUE, echo=TRUE>>=
fsamp <- 20
fNyq <- fsamp / 2
freqs <- fsamp * nyfreqs 
Snew <- S / fsamp
@

To compare the scalings it is helpful to instead show the spectral values
in decibels (relative to 1 units$^2/$frequency).
\begin{figure}[htb!]
\begin{center}
<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=PSD2>>=
    # decibel function
dB <- function(y) 10*log10(y)
    # and some plots...
plot(freqs, dB(S), type="h", xlab="Frequency", ylab="dB")
lines(freqs, dB(Snew), col="blue", lwd=2)
abline(h=dB(1/fNyq), col="grey", lwd=2)
mSn <- mean(Snew)
lines(c(0,fNyq), rep(dB(mSn),2), lwd=2, lty=2, col="red")
    # finally, test variance.
test_norm(mSn, fNyq, xv)
@
\label{fig:psdsamp}
\caption{Rescaled PSD estimates for a single realization of a 
$\mathcal{N}(0,1)$ process with a sampling rate of 20 s$^{-1}$ rather
than 1 s$^{-1}$ as from before.  
The dashed line shows the mean (rescaled) spectral level, and the
grey line shows the predicted mean value from the Nyquist
frequency.}
\end{center}
\end{figure}

\section{Comparisons between estimators}
We wish to compare the normalizations used by other PSD estimation programs;
these are summarized in \ref{tbl:methods}.
\input{tbl_specprogs}

\subsection{\Rcmd{stats::spectrum}}
\Rcmd{spectrum} is a wrapper which calls the appropriate spectrum
estimator. For our examples we compare to \Rcmd{spec.pgram}.
Using default settings \Rcmd{spec.pgram} assumes the sampling frequency
for the input series is 1, and normalizes accordingly.
Sampling information used be included by creating a \Rcmd{ts}
object from the series prior to spectrum estimation:
%
<<eval=TRUE, echo=TRUE>>=
fsamp <- 20
xt <- ts(x, frequency=fsamp)
pgram20 <- spec.pgram(xt, pad=1, taper=0, plot=FALSE)
pgram01 <- spec.pgram(ts(xt, frequency=1), pad=1, taper=0, plot=FALSE)
@

The first order question is obviously whether these spectra pass variance-normalization
tests, which they do not, but only by a factor of two (too small):
%
\begin{figure}[htb!]
\begin{center}
<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=PGRAM>>=
test_norm(mean(pgram01$spec), 0.5, xv)
test_norm(mean(pgram20$spec), 10, xv)
plot(pgram20, log="dB", ylim=36*c(-1,.3))
plot(pgram01, log="dB", add=TRUE, col="red")
abline(h=dB(c(1, 1/2/1, 1/2/20)), col=c("grey","red","black"))
@
\label{fig:pgram}
\caption{\Rcmd{spec.pgram}}
\end{center}
\end{figure}

But why?  The program assumes normalization for complex series: Spectra returned for
real data are deficient by a factor of two. Consider the following example:
%
<<eval=TRUE, echo=TRUE>>=
psd1 <- spec.pgram(x, plot=FALSE)
psd2 <- spec.pgram(xc<-complex(real=x, imag=x), plot=FALSE, demean=TRUE)
mean(Mod(xc))
mean((psd2$spec / psd1$spec))
@

This means that unless we are interested in analyzing complex
timeseries, we need only multiply by two for properly normalized spectra using \Rcmd{spectrum}, assuming the sampling information is included in the input series.

%<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=RSEIS>>=
%@
%
%<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=MTM>>=
%@
%% RSEIS mtapspec
%     /* choose normalization based on inorm flag  */
%	anrm = 1.;
%	switch (inorm) {
%	case 0:
%		anrm = 1.;
%		break;
%	case 1:
%		anrm = npoints;
%		break;
%	case 2:
%		anrm = 1 / dt;
%		break;
%	case 3:
%		anrm = sqrt((double) npoints);
%		break;
%	default:
%		anrm = 1.;
%		break;
% then
%  norm = 1.0/(anrm*anrm);
%	
%<<eval=TRUE, echo=TRUE>>=
%Mspec <- mtapspec(a, dt, MTP=list(kind=1, nwin=5, npi=3, inorm = 3))
%str(Mspec)
%@
%where \Rcmd{nwin} is the number of tapers taken, and 
%\Rcmd{inorm} is he normalization flag.  Digging a bit into .
%       a: vector time series
%      dt: sample rate
%    klen: length of fft
%     MTP: MTM parameters, list:
%          kind kind of taper average
%          nwin number of windows
%          npi number of Pi-prolate functions
%          inorm normalization flag
%We obviously need to deal with the sampling information since it is not
%one (as assumed by default).  
%The information we have is that the 
%measurements are taken every 0.3 seconds.
%We can use account for the
%sampling interval (as opposed to sampling rate) easily
%by using a negative value for \Rcmd{X.frq}, which \Rcmd{psdcore}
%will interpret as
%an interval instead of a frequency. 
%An example highlights this:
%% samp inv vs frq
%<<eval=TRUE, echo=TRUE>>=
%all.equal(psdcore(a,1)$spec, psdcore(a,-1)$spec)
%@
%
%Returning to the $\delta$O$_{18}$ data, we can now calculate the spectrum:
%%% adaptive OH PSD
%<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_rseis_OH>>=
%Aspec <- pspectrum(a, -dt, 5, niter=1, plot=FALSE)
%Pspec <- psdcore(a, -dt, 5)
%pltf <- Mspec$freq
%nt <- 1:Mspec$numfreqs
%# multiply by Nyquist
%nyq <- frequency(ats)/2
%pltp <- dB(Mspec$spec[nt] * nyq)
%Xspec <- spec.pgram(ts(a, frequency=1), pad=1, taper=0.2, detrend=TRUE, demean=TRUE, plot=FALSE)
%Xspec$freq <- Xspec$freq * 2 * nyq
%Xspec$spec <- nyq * Xspec$spec
%plot(Xspec, log="dB", col="dark grey")
%plot(Pspec, log="dB", add=TRUE)
%lines(pltf, pltp, col="dark red")
%plot(Aspec, log="dB", add=TRUE, col="dark blue", lwd=1.5)
%@
%
%This is a situation where the adaptive method can be overly aggressive
%in taper application. Remember, it all depends on the spectral shape.
%
%and enhance 
%instead with an adaptive procedure:
%Pspec <- pspectrum(a, -dt, 5, verbose=FALSE, no.history=TRUE, plot=TRUE)



\subsection{\Rcmd{stats::spectrum}}
Included in the core distribution of R is \Rcmd{stats::spectrum}, which
accesses \Rcmd{stats::spec.ar} or \Rcmd{stats::spec.pgram} for either
parametric and non-parametric estimation, respectively.  
The user can optionally apply a single cosine taper, and/or a smoothing kernel.
Our method is non-parametric; hence, we will compare to the latter.

%% pgram
<<eval=FALSE, echo=TRUE>>=
spec.pgram(X, pad=1, taper=0.2, detrend=FALSE, demean=FALSE, plot=FALSE)
@
However,
the logical arguments \Rcmd{detrend} and \Rcmd{demean} to \Rcmd{psdcore}
are passed to \Rcmd{spec.pgram}; they are,
by default, both \SC{True}.

As a matter of bookkeeping, we must deal with the working environment
accessed by \rlp{} functions.
Specifically, 
we should ensure
\Rcmd{psdcore} does not access any inappropriate information by
setting \Rcmd{refresh=TRUE}.
We can then
re-calculate the multitaper PSD and the
raw periodogram with \Rcmd{plotpsd=TRUE}.  
The results are shown in Figure \ref{fig:two}.

%\begin{figure}[htbp!]
%\begin{center}
%%% magsat compare
%<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_magsat_naive>>=
%data(magsat)
%psdcore(magsat$clean, ntaper=10, refresh=TRUE, plotpsd=TRUE)
%@
%\caption{Top: Comparison between \naive{} and multitaper PSD estimators for the 
%clean \Rcmd{MAGSAT} data. The frequency axis is in units of $\log_{10}$ km$^{-1}$,
%and power axis is in decibels.
%Bottom: The spatial series used to estimate the PSDs.}
%\end{center}
%\label{fig:two}
%\end{figure}

\subsection{\Rcmd{multitaper::spec.mtm}}
\subsection{\Rcmd{SDF::sapa}}

%% bib
\bibliographystyle{apalike}
\bibliography{REFS}

\printindex
\end{document}

\documentclass[12pt]{article}
% sweave fig help:
% http://users.stat.umn.edu/~geyer/Sweave/foo.pdf
% borrowing design from roxygen -- AJB Jan 13
%% \VignetteIndexEntry{rlpSpec Normalization Vignette}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{amssymb}
\usepackage{float}
\usepackage{natbib}
\usepackage{fullpage}
\usepackage{makeidx} % for indexing
\usepackage{showidx} % shows page (remove when complete)
\makeindex % comment to have no index
%%
\include{symdefs}
%%
\newcommand{\SC}[1]{\textsc{#1}}
\newcommand{\SCY}[0]{\SC{Yes}}
\newcommand{\SCN}[0]{\SC{No}}
\newcommand{\Rcmd}[1]{\texttt{#1}}
\newcommand{\rlp}[0]{\Rcmd{rlpSpec}}
\newcommand{\naive}[0]{na\"{\i}ve}
\newcommand{\bidx}[1]{\index{#1}{\textbf{#1}}} 
\newcommand{\idx}[1]{\index{#1}{#1}} 
%% path, filename, caption, label
\newcommand{\listing}[4]{        %
  \begin{figure}[H]              %
    \centering                   %
    \VerbatimInput[numbers=left, %
      frame=single,              %
      label=#2]{#1}              %
    \caption{#3}                 %
    \label{#4}                   %
  \end{figure}                   %
}
\author{Andrew J. Barbour}
\title{Normalization of Spectral Analyses}
\begin{document}
\maketitle
\begin{abstract}
%  Normalizations come in many forms, depending
%  on the quantity in consideration.
  Units matter, and having correct ones
  is crucial to interpretation of spectral
  analyses.
  Here we outline
  the normalization used by \rlp{}, namely
  the power spectral density, 
  and compare it to other quantities 
  commonly encountered in spectral analysis.
\end{abstract}
\tableofcontents
\section{Background}
There can often be confusion about the different quantities used
in spectral analysis \footnote{
This post to \Rcmd{R-help} illustrates the confusion common in spectral analyses:\\
\url{http://r.789695.n4.nabble.com/Re-How-do-I-normalize-a-PSD-td792902.html}
%https://stat.ethz.ch/pipermail/r-help/2006-February/087377.html
},
partly due to myriad nomenclature within the incredibly vast literature
on the subject.
Regarding nomenclature:
Phrases including ``amplitude spectrum",
``energy spectral density", ``power", ``power spectra", and even "spectra"
all mean \emph{something}, but are rarely equivalent.

Let us, for the sake of brevity, assume we are in 
the time domain, and we are considering a discrete stationary signal \df{}
of length $N$,
having Fourier transform \dFTp{f}\footnote{
A proper Discrete Fourier Transform (DFT) must
be normalized by the length of the series; however, most
DFT programs (including \Rcmd{stats::fft}) eschew this normalization for 
efficiency's sake.
} which is complex, and represented by\dF{}.
The \bidx{amplitude spectrum}
of this transform pair is simply the 
amplitude of \dF{}, or \dmodF{}; we will denote this as \daS{}.
The pair's corresponding \bidx{phase spectrum}
is the phase angle of \dF{}, or \dargF{}, denoted by \dpS{}.

How do we interpret the quantities 

Table with equivalent expressions
\input{tbl_norms}

\input{tbl_specprogs}

The latter assumes that the
spectrum has the normalization used in  power -- which is that the Nyquist
is assumed to be 1,0, always (power doesn't ask for a sample interval).
But psd assumes that the interval is 1 (unless you specify otherwise)
so that the Nyquist is 0.5. So say you have a white noise with variance
1: power will return a flat spectrum with level 0 db (=1) but psd will
return a level of 2 (=3 db), both so that the level times the Nyquist will be 1.
But logsmoo, told that the interval is 1, will multiply the spectrum by
2 to convert from lc**2/Nyquist to lc**2/Hz: giving 3 dB for the spectrum from
power, but 6 dB (=4) for the spectrum from psd.

A straightforward way to understand normalization in spectral analysis
is to analyze a real, stationary series which is normally distributed with
known variance, $x=\mathcal{N}(\mu,\sigma^2)$.
A fundamental result found in many texts on spectral analysis is
%
\begin{equation}
\mathrm{var}\{x\} \equiv \sigma_x^2 = \int_{-1/2}^{1/2} \dS{}(f) df 
\end{equation}
%
which says if we integrate the power spectral density
over all frequencies we can obtain the process variance.
If we have a $\mathcal{N}(0, 1)$ process, and assume the sampling
interval is once per second, we should expect a
 flat spectrum of 2 units$^2/$Nyquist 
across all frequencies $[0, 0.5]$ so that the area under the spectrum is
equal to one.

<<eval=TRUE, echo=TRUE>>=
set.seed(1234)
N <- 256
x <- rnorm(N, mean = 0, sd = 1)
xv <- var(x)
X <- fft(x)
class(X)
length(X)
@

Let us first find the amplitude and phase response:
<<eval=TRUE, echo=TRUE>>=
Sa <- Mod(X) # Amplitude spectrum
Sp <- Arg(X)  # Phase spectrum
@

followed by the energy spectral densities, noting the equivalence
between the complex conjugate based estimates.
between
<<eval=TRUE, echo=TRUE>>=
XC <- Conj(X)
all.equal(Se <- Sa**2, Se_2 <- Mod(XC * X), Se_2R <- Mod(X * XC))
@

So now we are able to find single-sided power spectral density estimates
\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, width=6, height=3.5, fig=TRUE, label=PSD>>=
## Single sided PSD
Nf <- N/2
S <- 2*Se[1:Nf]/N
fsamp <- 1  # sampling freq, Hz
fNyq <- fsamp/2   # nyquist or shannon(?) freq
nyfreq <- seq.int(from=0, to=fNyq, length.out=Nf) # frequencies
plot(nyfreq, S, type="h", xlab="Nyquist frequency", ylab="units**2 / Nyq.-freq.", main="")
lines(nyfreq, S) #, type="s")
mSn <- mean(S)
#abline(h=xv/fNyq, lwd=2) # expected PSD for N(0,1)
polygon(c(0,fNyq,fNyq,0,0), c(0,0,mSn,mSn,0), lwd=2, lty=4, border="red")
@
\label{fig:psdN}
\caption{Power spectral density of a single $\mathcal{N}(0,1)$ process.}
\end{center}
\end{figure}

We test the integrated spectrum result in Equation X:
<<eval=TRUE, echo=TRUE>>=
dB <- function(y) 10*log10(y)
# Approximations of process variance:
xv_1 <- mSn * fNyq
xv_2 <- sum(S)/Nf * fNyq
all.equal(xv_1, xv_2)
xv_1/xv
@

We test the integrated spectrum result in Equation X:
<<eval=TRUE, echo=TRUE>>=
# crude representation of the integrated spectrum, which
# should equal the variance of the original series (xv)
S_sum <- function(S_ave, fr, fl=0) S_ave*(fr - fl)
S_sum(mSn, fNyq)/xv             #1 
S_sum(mSn, fNyq, -fNyq)/xv      #2
sum(Se)/N/N                     #1
mSe <-round(mean(Se))
S_sum(mSe, fNyq)/xv             #64
S_sum(mSe, fNyq)/Nf/xv          #1
@

<<eval=TRUE, echo=TRUE>>=
freq <- fsamp*nyfreq # Nyq-freq to Hz

S0 <- dB(2)
@ 


%% RSEIS mtapspec
%     /* choose normalization based on inorm flag  */
%	anrm = 1.;
%	switch (inorm) {
%	case 0:
%		anrm = 1.;
%		break;
%	case 1:
%		anrm = npoints;
%		break;
%	case 2:
%		anrm = 1 / dt;
%		break;
%	case 3:
%		anrm = sqrt((double) npoints);
%		break;
%	default:
%		anrm = 1.;
%		break;
% then
%  norm = 1.0/(anrm*anrm);
%	
%<<eval=TRUE, echo=TRUE>>=
%Mspec <- mtapspec(a, dt, MTP=list(kind=1, nwin=5, npi=3, inorm = 3))
%str(Mspec)
%@
%where \Rcmd{nwin} is the number of tapers taken, and 
%\Rcmd{inorm} is he normalization flag.  Digging a bit into .
%       a: vector time series
%      dt: sample rate
%    klen: length of fft
%     MTP: MTM parameters, list:
%          kind kind of taper average
%          nwin number of windows
%          npi number of Pi-prolate functions
%          inorm normalization flag
%We obviously need to deal with the sampling information since it is not
%one (as assumed by default).  
%The information we have is that the 
%measurements are taken every 0.3 seconds.
%We can use account for the
%sampling interval (as opposed to sampling rate) easily
%by using a negative value for \Rcmd{X.frq}, which \Rcmd{psdcore}
%will interpret as
%an interval instead of a frequency. 
%An example highlights this:
%% samp inv vs frq
%<<eval=TRUE, echo=TRUE>>=
%all.equal(psdcore(a,1)$spec, psdcore(a,-1)$spec)
%@
%
%Returning to the $\delta$O$_{18}$ data, we can now calculate the spectrum:
%%% adaptive OH PSD
%<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_rseis_OH>>=
%Aspec <- pspectrum(a, -dt, 5, niter=1, plot=FALSE)
%Pspec <- psdcore(a, -dt, 5)
%pltf <- Mspec$freq
%nt <- 1:Mspec$numfreqs
%# multiply by Nyquist
%nyq <- frequency(ats)/2
%pltp <- dB(Mspec$spec[nt] * nyq)
%Xspec <- spec.pgram(ts(a, frequency=1), pad=1, taper=0.2, detrend=TRUE, demean=TRUE, plot=FALSE)
%Xspec$freq <- Xspec$freq * 2 * nyq
%Xspec$spec <- nyq * Xspec$spec
%plot(Xspec, log="dB", col="dark grey")
%plot(Pspec, log="dB", add=TRUE)
%lines(pltf, pltp, col="dark red")
%plot(Aspec, log="dB", add=TRUE, col="dark blue", lwd=1.5)
%@
%
%This is a situation where the adaptive method can be overly aggressive
%in taper application. Remember, it all depends on the spectral shape.
%
%and enhance 
%instead with an adaptive procedure:
%Pspec <- pspectrum(a, -dt, 5, verbose=FALSE, no.history=TRUE, plot=TRUE)



\subsection{\Rcmd{stats::spectrum}}
Included in the core distribution of R is \Rcmd{stats::spectrum}, which
accesses \Rcmd{stats::spec.ar} or \Rcmd{stats::spec.pgram} for either
parametric and non-parametric estimation, respectively.  
The user can optionally apply a single cosine taper, and/or a smoothing kernel.
Our method is non-parametric; hence, we will compare to the latter.

%% pgram
<<eval=FALSE, echo=TRUE>>=
spec.pgram(X, pad=1, taper=0.2, detrend=FALSE, demean=FALSE, plot=FALSE)
@
However,
the logical arguments \Rcmd{detrend} and \Rcmd{demean} to \Rcmd{psdcore}
are passed to \Rcmd{spec.pgram}; they are,
by default, both \SC{True}.

As a matter of bookkeeping, we must deal with the working environment
accessed by \rlp{} functions.
Specifically, 
we should ensure
\Rcmd{psdcore} does not access any inappropriate information by
setting \Rcmd{refresh=TRUE}.
We can then
re-calculate the multitaper PSD and the
raw periodogram with \Rcmd{plotpsd=TRUE}.  
The results are shown in Figure \ref{fig:two}.

%\begin{figure}[htbp!]
%\begin{center}
%%% magsat compare
%<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_magsat_naive>>=
%data(magsat)
%psdcore(magsat$clean, ntaper=10, refresh=TRUE, plotpsd=TRUE)
%@
%\caption{Top: Comparison between \naive{} and multitaper PSD estimators for the 
%clean \Rcmd{MAGSAT} data. The frequency axis is in units of $\log_{10}$ km$^{-1}$,
%and power axis is in decibels.
%Bottom: The spatial series used to estimate the PSDs.}
%\end{center}
%\label{fig:two}
%\end{figure}

\subsection{\Rcmd{multitaper::spec.mtm}}
\subsection{\Rcmd{SDF::sapa}}

%% bib
\bibliographystyle{apalike}
\bibliography{REFS}

\printindex
\end{document}

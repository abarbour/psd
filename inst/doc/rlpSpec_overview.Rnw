\documentclass{article}
% sweave fig help:
% http://users.stat.umn.edu/~geyer/Sweave/foo.pdf
% borrowing design from roxygen -- AJB Jan 13
%% \VignetteIndexEntry{rlpSpec Overview Vignette}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{float}
\usepackage{natbib}
\usepackage{fullpage}
\newcommand{\SC}[1]{\textsc{#1}}
\newcommand{\SCY}[0]{\SC{Yes}}
\newcommand{\SCN}[0]{\SC{No}}
\newcommand{\Rcmd}[1]{\texttt{#1}}
\newcommand{\rlp}[0]{\Rcmd{rlpSpec}}
\newcommand{\naive}[0]{na\"{\i}ve}
%% path, filename, caption, label
\newcommand{\listing}[4]{        %
  \begin{figure}[H]              %
    \centering                   %
    \VerbatimInput[numbers=left, %
      frame=single,              %
      label=#2]{#1}              %
    \caption{#3}                 %
    \label{#4}                   %
  \end{figure}                   %
}
\author{Andrew J. Barbour and Robert L. Parker}
\title{\rlp{}: Adaptive sine multitaper power spectral density estimation}
\begin{document}
\maketitle
\begin{abstract}
  The purpose of this vignette is to provide an overview of the
  features included in \rlp{}, which allow the
  user to compute sophisticated power spectral
  density (PSD) estimates for a univariate series, with very little tuning effort.
  The sine multitapers are used in which
  the number of tapers varies with spectral shape, according
  to the optimal value proposed by \citet{rs1995}.
  The adaptive procedure
  iteratively refines the optimal number of tapers at each frequency,
  which, assuming convergence, will produce
  spectra with significantly
  reduced variance (compared to \naive{} estimators),
  and minimum biasing effects.
  Resolution and uncertainty in a multitaper scheme
  are controlled by the number of tapers used.
  This means we do
  not need to resort to either windowing methods 
  which inherently degrade resolution of low-frequency features
  (e.g. Welch), or smoothing kernels 
  which can badly distort important features without careful tuning
  (e.g. Daniell, as in \Rcmd{stats::spec.pgram}).
  In this sense
  \rlp{} is best suited for data having
  spectra with both large dynamic range and strong, sharply changing features.
\end{abstract}
\tableofcontents
\section{Quick start: A minimal example.}

%\listing{graph.R} % src
%	{graph} % src label
%	{Call matrix}	% caption
%	{fig:callmat}	% fig label

First load the package into the namespace:
%% libload
<<eval=TRUE, eval=TRUE>>=
library(rlpSpec)
@ 
We now need a dataset to analyze.
Among the datasets included in \rlp{} is a subset of
the Magnetic Satellite (MAGSAT) mission \citep{langel1982}.
Specifically, we have included along-track measurements
of horizontal magnetic-field strength from a gimballed, airborne magnetometer,
sampled once every kilometer, which means the spectrum may represent
crustal magnetization with wavelengths longer than 2 km.
%% magsat data
<<eval=TRUE, eval=TRUE>>=
data(magsat)
@ 
The format of the data set is a \Rcmd{data.frame} with four
sets of information:
%%
<<eval=TRUE, eval=TRUE>>=
names(magsat)
@ 
The \Rcmd{raw} and \Rcmd{clean} names represent raw
and edited intensities respectively, expressed in units of nanoTesla; 
\Rcmd{mdiff} is the difference between them.
The difference between them is a matter of just a few points
attributable to instrumental malfunction. 
%% edits
<<eval=TRUE, echo=TRUE>>=
subset(magsat, abs(mdiff)>0)
@
These deviations can,
as we will see, adversely affect the accuracy of any PSD estimate,
multitaper or otherwise.

Setting aside any discussion regarding sample stationarity,
we can find power spectral density (PSD)
estimates for the two series quite simply:
%% pspectrum
<<eval=FALSE, echo=TRUE>>=
psdr <- pspectrum(magsat$raw, verbose=FALSE)
psdc <- pspectrum(magsat$clean, verbose=FALSE)
@
Each  \Rcmd{pspectrum} command calculates a pilot PSD, followed by four
iterations of refinement (the default).
With each iteration
the number of tapers is adjusted 
to the optimal number, based on the weighted
spectral derivatives, following \citet{rs1995}.
In general, spectral variance is reduced
with sequential refinements, but is not necessarily quaranteed to converge.
Note that in the example
the sampling frequency of both series
is km$^{-1}$, so we need not change the sampling rate
argument.

Let's now visualize the two PSD estimates, recalling that the difference between
the \Rcmd{raw} and \Rcmd{clean} samples is a mere two points.
\footnote{
Note that \Rcmd{pspectrum} returns
an object with class \Rcmd{spec}, so we have access to methods 
within \Rcmd{stats}, including \Rcmd{plot.spec}.
}

\begin{figure}[htbp!]
\begin{center}
%% magsat comparison
<<eval=FALSE, fig=TRUE, echo=TRUE, label=fig_magsat>>=
plot(psdc, log="dB")
lines(psdr$freq, dB(psdr$spec), col="red")
legend("bottomleft",c("magsat$raw","magsat$clean"),col=c("red","black"),lty=1,lwd=2)
@
\end{center}
\caption{Comparison of power spectral densities for the \Rcmd{MAGSAT} data
included with \rlp{}.}
\label{fig:one}
\end{figure}

Figure \ref{fig:one} compares the spectra for the \Rcmd{raw} and \Rcmd{clean} 
samples.  This plot shows a
drastic improvement in shape between the two series,
simply because the large outliers have been removed.
The \Rcmd{clean} PSD shows the
very red spectrum typical of geophysical processes \citep{agnew1992}.
It also shows a rolloff in signal
somewhere around the 20 kilometer wavelengths; whereas, the 
\Rcmd{raw} PSD looks highly unrealistic at higher wavelengths, and
shows some curvature bias at low frequencies.

\section{Comparisons with other methods}

As we have shown in the MAGSAT example, 
improved understanding of the physics behind the signals in the data
is of great concern.
Assuming a sample is free of non-physical points, how do
PSD estimates from \rlp{}
compare with other methods?
Unfortunately the suite of extensions with similar functionality
is relatively limited; hopefully we have
summarized the available functions in Table \ref{tbl:methods}.

%\begin{table}[htbp!]
%\centering
%\caption{A comparison of functions comparable to \rlp{}, excluding
%raw periodogram estimators.}
%\begin{tabular}{r l c c l}
%\hline
%\SC{Function} & \SC{Namespace} & \SC{Sine m.t.?} & \SC{Adaptive?} & \SC{Reference} \\
%\hline
%\Rcmd{mtapspec} & \Rcmd{RSEIS} & \SCY{} & \SCN{} & \citet{lees1995} \\
%\Rcmd{spectrum} & \Rcmd{stats} & \SCN{} & \SCN{} & \citet{rcore} \\
%\Rcmd{spec.mtm} & \Rcmd{multitaper} & \SCY{} & \SCY{} & \citet{rahim2012} \\
%\Rcmd{SDF} & \Rcmd{sapa} & \SCY{} & \SCN{} & \citet{percival1993} \\
%\hline
%\end{tabular}
%\label{tbl:methods}
%\end{table}
\input{tbl_specprogs}

We now perform some tests to get a sense of how the results of
\rlp{} compare with the methods in Table \ref{tbl:methods}.

\subsection{\Rcmd{RSEIS::mtapspec}}
%% RSEIS load
For this comparison we will
use a dataset contained in \Rcmd{RSEIS}
representing $\delta$O$_{18}$ timeseries, namely \Rcmd{OH}.
<<eval=TRUE, eval=TRUE, echo=TRUE>>=
require(stats)
require(RSEIS)
data(OH)
print(dt <- OH$dt[1]) # sampling interval, seconds
a <- OH$JSTR[[1]]     # OH18 data
@
These data are shown in Figure \ref{fig:OH}.

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, height=7, width=7, label=OH_data>>=
ats <- prewhiten(ts(a, deltat=dt)) # remove an Ax+B model by default
@
\label{fig:OH}
\caption{Pre-processed $\delta$O$_{18}$ timeseries from the \Rcmd{RSEIS} package.}
\end{center}
\end{figure}

For harmonic analysis
we will follow, but modify slightly,
the procedure outlined in the \Rcmd{RSEIS} vignette \Rcmd{rseis}
\footnote{\url{http://cran.r-project.org/web/packages/RSEIS/vignettes/rseis.pdf}}
and calculate the multitaper spectrum for the following parameters:

%% RSEIS mtapspec
%     /* choose normalization based on inorm flag  */
%	anrm = 1.;
%	switch (inorm) {
%	case 0:
%		anrm = 1.;
%		break;
%	case 1:
%		anrm = npoints;
%		break;
%	case 2:
%		anrm = 1 / dt;
%		break;
%	case 3:
%		anrm = sqrt((double) npoints);
%		break;
%	default:
%		anrm = 1.;
%		break;
% then
%  norm = 1.0/(anrm*anrm);
	
<<eval=TRUE, echo=TRUE>>=
Mspec <- mtapspec(a, dt, MTP=list(kind=1, nwin=5, npi=3, inorm = 3))
str(Mspec)
@
where \Rcmd{nwin} is the number of tapers taken, and 
\Rcmd{inorm} is he normalization flag.  Digging a bit into .
%       a: vector time series
%      dt: sample rate
%    klen: length of fft
%     MTP: MTM parameters, list:
%          kind kind of taper average
%          nwin number of windows
%          npi number of Pi-prolate functions
%          inorm normalization flag
We obviously need to deal with the sampling information since it is not
one (as assumed by default).  
The information we have is that the 
measurements are taken every 0.3 seconds.
We can use account for the
sampling interval (as opposed to sampling rate) easily
by using a negative value for \Rcmd{X.frq}, which \Rcmd{psdcore}
will interpret as
an interval instead of a frequency. 
An example highlights this:
%% samp inv vs frq
<<eval=TRUE, echo=TRUE>>=
all.equal(psdcore(a,1)$spec, psdcore(a,-1)$spec)
@

Returning to the $\delta$O$_{18}$ data, we can now calculate the spectrum:
%% adaptive OH PSD
<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_rseis_OH>>=
Aspec <- pspectrum(a, -dt, 5, niter=1, plot=FALSE)
Pspec <- psdcore(a, -dt, 5)
pltf <- Mspec$freq
nt <- 1:Mspec$numfreqs
# multiply by Nyquist
nyq <- frequency(ats)/2
pltp <- dB(Mspec$spec[nt] * nyq)
Xspec <- spec.pgram(ts(a, frequency=1), pad=1, taper=0.2, detrend=TRUE, demean=TRUE, plot=FALSE)
Xspec$freq <- Xspec$freq * 2 * nyq
Xspec$spec <- nyq * Xspec$spec
plot(Xspec, log="dB", col="dark grey")
plot(Pspec, log="dB", add=TRUE)
lines(pltf, pltp, col="dark red")
plot(Aspec, log="dB", add=TRUE, col="dark blue", lwd=1.5)
@

This is a situation where the adaptive method can be overly aggressive
in taper application. Remember, it all depends on the spectral shape.

and enhance 
instead with an adaptive procedure:
%Pspec <- pspectrum(a, -dt, 5, verbose=FALSE, no.history=TRUE, plot=TRUE)

%\begin{figure}[htbp!]
%\begin{center}
%\label{}
%\caption{}
%\end{center}
%\end{figure}

\subsection{\Rcmd{stats::spectrum}}
Included in the core distribution of R is \Rcmd{stats::spectrum}, which
accesses \Rcmd{stats::spec.ar} or \Rcmd{stats::spec.pgram} for either
parametric and non-parametric estimation, respectively.  
The user can optionally apply a single cosine taper, and/or a smoothing kernel.
Our method is non-parametric; hence, we will compare to the latter.

Included in \rlp{} is an option to compare the 
results with a \naive{} estimator--a 20\% tapered periodogram--from within the
spectrum calculator, \Rcmd{psdcore}.
In R this estimator is equivalent to running:
%% pgram
<<eval=FALSE, echo=TRUE>>=
spec.pgram(X, pad=1, taper=0.2, detrend=FALSE, demean=FALSE, plot=F)
@
However,
the logical arguments \Rcmd{detrend} and \Rcmd{demean} to \Rcmd{psdcore}
are passed to \Rcmd{spec.pgram}; they are,
by default, both \SC{True}.

As a matter of bookkeeping, we must deal with the working environment
accessed by \rlp{} functions.
Specifically, 
we should ensure
\Rcmd{psdcore} does not access any inappropriate information by
setting \Rcmd{refresh=TRUE}.
We can then
re-calculate the multitaper PSD and the
raw periodogram with \Rcmd{plotpsd=TRUE}.  
The results are shown in Figure \ref{fig:two}.

\begin{figure}[htbp!]
\begin{center}
%% magsat compare
%<<eval=TRUE, echo=TRUE, fig=TRUE, width=8, height=6, label=fig_magsat_naive>>=
<<eval=FALSE, echo=TRUE, fig=TRUE, label=fig_magsat_naive>>=
ntap <- psdc$taper
psdcore(magsat$clean, ntaper=ntap, refresh=TRUE, plotpsd=TRUE)
@
%str(rlp_envStatus())
\caption{Top: Comparison between \naive{} and multitaper PSD estimators for the 
clean \Rcmd{MAGSAT} data. The frequency axis is in units of $\log_{10}$ km$^{-1}$,
and power axis is in decibels.
Bottom: The spatial series used to estimate the PSDs.}
\end{center}
\label{fig:two}
\end{figure}

\subsection{\Rcmd{multitaper::spec.mtm}}
	Adaptive sine multitaper option has nearly identical functionality: 
	it calls source code of a Fortran equivalent to rlp{}, 
	also written by R.L. Parker.
	By default it uses the
	Discrete Prolate Spheroidal Sequences (dpss) of \citet{thomson1982},
	so there can be	many more knobs to turn.\\

Among the other functions included in \Rcmd{multitaper} is \Rcmd{spec.mtm}.

In fact, this function calls portions of the Fortran equivalent of 
\rlp{}

\subsection{\Rcmd{SDF::sapa}}
	As of this writing, the package has no maintainer; 
	lest we discuss deprecated and archived functions,
	we will not review its capabilities.\\

\section{Assessing spectral properties}
In a multitaper scheme,
the computation of resolution and uncertainty (shown as blue lines
in Figure \ref{fig:one} depends on the 
the number of tapers; hence, the methods internal to \Rcmd{plot.spec}
are not appropriate.

%%
\section{Call overview}

\begin{figure}[htbp!]
 \centering
 \includegraphics[width=0.6\textwidth]{yuml_d.png}%%
 \includegraphics[width=0.4\textwidth]{yuml_n.png}
 \caption{Simplified call graph for \rlp{}. The dashed lines show the circuit
 in which the spectra and its tapers make during the iterative process.}
 \label{fig:calls}
\end{figure}

%%
\bibliographystyle{apalike} %plainnat}
\bibliography{REFS}
\end{document}

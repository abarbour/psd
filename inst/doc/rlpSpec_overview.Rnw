\documentclass{article}
% sweave fig help:
% http://users.stat.umn.edu/~geyer/Sweave/foo.pdf
% borrowing design from roxygen -- AJB Jan 13
%% \VignetteIndexEntry{rlpSpec Overview Vignette}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{upquote}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{float}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{fullpage}
\newcommand{\SC}[1]{\textsc{#1}}
\newcommand{\SCY}[0]{\SC{Yes}}
\newcommand{\SCN}[0]{\SC{No}}
\newcommand{\Rcmd}[1]{\texttt{#1}}
\newcommand{\rlp}[0]{\Rcmd{rlpSpec}}
\newcommand{\naive}[0]{na\"{\i}ve}
%% path, filename, caption, label
\newcommand{\listing}[4]{        %
  \begin{figure}[H]              %
    \centering                   %
    \VerbatimInput[numbers=left, %
      frame=single,              %
      label=#2]{#1}              %
    \caption{#3}                 %
    \label{#4}                   %
  \end{figure}                   %
}
\author{Andrew J. Barbour and Robert L. Parker}
\title{\rlp{}: Adaptive sine multitaper power spectral density estimation}
\begin{document}
\maketitle
\begin{abstract}
  The purpose of this vignette is to provide an overview of the
  features included in \rlp{}, which allow the
  user to compute sophisticated power spectral
  density (PSD) estimates for a univariate series, with very little tuning effort.
  The sine multitapers are used in which
  the number of tapers varies with spectral shape, according
  to the optimal value proposed by \citet{rs1995}.
  The adaptive procedure
  iteratively refines the optimal number of tapers at each frequency,
  which, assuming convergence, will produce
  spectra with significantly
  reduced variance (compared to \naive{} estimators),
  and minimum biasing effects.
  Resolution and uncertainty in a multitaper scheme
  are controlled by the number of tapers used.
  This means we do
  not need to resort to either windowing methods 
  which inherently degrade resolution of low-frequency features
  (e.g. Welch), or smoothing kernels 
  which can badly distort important features without careful tuning
  (e.g. Daniell, as in \Rcmd{stats::spec.pgram}).
  In this sense
  \rlp{} is best suited for data having
  spectra with both large dynamic range and strong, sharply changing features.
\end{abstract}
\tableofcontents
\section{Quick start: A minimal example.}

%\listing{graph.R} % src
%	{graph} % src label
%	{Call matrix}	% caption
%	{fig:callmat}	% fig label

First load the package into the namespace:
%% libload
<<eval=TRUE, eval=TRUE>>=
library(rlpSpec)
@ 
We now need a dataset to analyze.
Among the datasets included in \rlp{} is a subset of
the Magnetic Satellite (MAGSAT) mission \citep{langel1982}.
Specifically, we have included along-track measurements
of horizontal magnetic-field strength from a gimballed, airborne magnetometer,
sampled once every kilometer, which means the spectrum may represent
crustal magnetization with wavelengths longer than 2 km.
%% magsat data
<<eval=TRUE, eval=TRUE>>=
data(magsat)
@ 
The format of the data set is a \Rcmd{data.frame} with four
sets of information:
%%
<<eval=TRUE, eval=TRUE>>=
names(magsat)
@ 
The \Rcmd{raw} and \Rcmd{clean} names represent raw
and edited intensities respectively, expressed in units of nanoTesla; 
\Rcmd{mdiff} is the difference between them.
The difference between them is a matter of just a few points
attributable to instrumental malfunction. 
%% edits
<<eval=TRUE, echo=TRUE>>=
subset(magsat, abs(mdiff)>0)
@
These deviations can,
as we will see, adversely affect the accuracy of any PSD estimate,
multitaper or otherwise.

Setting aside any discussion regarding sample stationarity,
we can find power spectral density (PSD)
estimates for the two series quite simply:
%% pspectrum 4 iters
<<eval=TRUE, echo=TRUE>>=
psdr <- pspectrum(magsat$raw)
psdc <- pspectrum(magsat$clean)
@
Each  \Rcmd{pspectrum} command calculates a pilot PSD, followed by 
\Rcmd{niter}
iterations of refinement.
With each iteration
the number of tapers is adjusted 
to the optimal number, based on the weighted
spectral derivatives, following \citet{rs1995}.
In general, spectral variance is reduced
with sequential refinements\footnote{
Messages given by \Rcmd{pspectrum} with
``Ave. S.V.R."  
are in reference to the 
 average spectral-variance reduction, found from
 double-differenced spectra for each stage relative
 to the pilot estimate.
}, but is not necessarily guaranteed to converge.
Note that in the example
the sampling frequency of both series
is km$^{-1}$, so we need not change the sampling rate
argument.

Let's now visualize the two PSD estimates, recalling that the difference between
the \Rcmd{raw} and \Rcmd{clean} samples is a mere two points.
\footnote{
Note that \Rcmd{pspectrum} returns
an object with class \Rcmd{spec}, so we have access to methods 
within \Rcmd{stats}, including \Rcmd{plot.spec}.
}

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, fig=TRUE, echo=TRUE, label=fig_magsat>>=
plot(psdc, log="dB", main="Raw and Clean MAGSAT power spectral density", 
       lwd=3, ci.col=NA, ylim=c(0,32), yaxs="i")
plot(psdr, log="dB", add=TRUE, lwd=3, lty=5)
text(0.25, 11 ,"Clean", cex=1)
text(0.34, 24, "Raw", cex=1)
@
\caption{Power spectral density estimates for the raw and cleaned
             \Rcmd{MAGSAT} data included with \rlp{}.}
\label{fig:pmag}
\end{center}
\end{figure}

Figure \ref{fig:pmag} compares the spectra for the \Rcmd{raw} and \Rcmd{clean} 
samples.  This plot shows a
drastic improvement in shape between the two series,
simply because the large outliers have been removed.
The \Rcmd{clean} PSD shows the
very red spectrum typical of geophysical processes \citep{agnew1992}.
It also shows a rolloff in signal
for 10 kilometer wavelengths and longer; whereas, the 
\Rcmd{raw} PSD looks highly unrealistic at higher wavelengths, and
shows some curvature bias.

\section{Comparisons with other methods}

As we have shown in the MAGSAT example, 
improved understanding of the physics behind the signals in the data
is of great concern.
Assuming a sample is free of non-physical points, how do
PSD estimates from \rlp{}
compare with other methods?
Unfortunately the suite of extensions with similar functionality
is relatively limited, but hopefully we have
summarized most, if not all, the available functions in Table \ref{tbl:methods}.

\input{tbl_specprogs}

We now perform some tests to get a sense of how the results of
\rlp{} compare with the methods in Table \ref{tbl:methods} for
the same data, specifically the cleaned MAGSAT series.

%%
%% spectrum
%%
\subsection{\Rcmd{stats::spectrum}}

Included in the core distribution of R is \Rcmd{stats::spectrum}, which
accesses \Rcmd{stats::spec.ar} or \Rcmd{stats::spec.pgram} for either
parametric and non-parametric estimation, respectively.  
The user can optionally apply a single cosine taper, and/or a smoothing kernel.
Our method is non-parametric; hence, we will compare to the latter.

Included in \rlp{} is an option to compare the 
results with a \naive{} estimator--a 20\% tapered periodogram--from within the
spectrum calculator, \Rcmd{psdcore}.
In R this estimator is equivalent to running:
%
<<eval=FALSE, echo=TRUE>>=
spec.pgram(X, pad=1, taper=0.2, detrend=FALSE, demean=FALSE, plot=F)
@
except that in \Rcmd{psdcore}
the logical arguments \Rcmd{detrend} and \Rcmd{demean} 
are passed to \Rcmd{spec.pgram} and are,
by default, both \SC{True}.

As a matter of bookkeeping, we should deal with the working environment
accessed by \rlp{} functions.
Specifically, 
we should ensure
\Rcmd{psdcore} does not access any inappropriate information by
setting \Rcmd{refresh=TRUE}.
We can then
re-calculate the multitaper PSD and the
raw periodogram with \Rcmd{plotpsd=TRUE}.  
The results are shown in Figure \ref{fig:two}.

\begin{figure}[htb!]
\begin{center}
%% magsat compare
<<eval=TRUE, echo=TRUE, fig=TRUE,  label=fig_magsat_naive>>=
ntap <- psdc$taper
psdcore(magsat$clean, ntaper=ntap, refresh=TRUE, plotpsd=TRUE)
@
\caption{Top: Comparison between \naive{} and multitaper PSD estimators for the 
clean \Rcmd{MAGSAT} data. The frequency axis is in units of $\log_{10}$ km$^{-1}$,
and power axis is in decibels.
Middle: The number of tapers applied as a function of frequency from
the \Rcmd{plot.tapers} method. 
Bottom: The spatial series used to estimate the PSDs and a subset
of the full autocorrelation function.}
\label{fig:two}
\end{center}
\end{figure}

%\pagebreak
%%
%% RSEIS
%%
\subsection{\Rcmd{RSEIS::mtapspec}}

The main spectrum estimation tool is \Rcmd{mtapspec}, which
calls the program of \citet{lees1995}.
With this program
there are many tuning parameters to set, including
normalization and taper averaging flags.  For our
purposes the correct normalization for \Rcmd{mtapspec} is found
by using
\Rcmd{MTP=list(kind=2, inorm=3)} and scaling the results by 2 (to convert
double-sided spectra to single-sided spectra).

Let's assume \Rcmd{mtapspec} doesn't remove a mean and trend from the
input series.  We can do this easily with the \Rcmd{prewhiten} methods\footnote{
Although the name implies parametric fitting the
default operation is to assume a linear model of the form 
$f(x) = \alpha x + \beta + \epsilon$.
}.
<<eval=TRUE, echo=TRUE>>=
require(RSEIS)
dt=1 # km
ats <- prewhiten(ts(magsat$clean, deltat=dt), plot=FALSE) 
@
and if we set \Rcmd{AR.max} higher than zero, the program
would've fit an auto-regressive (AR)
model to the data.  In Figure \ref{fig:magd} we show the AR
fitting method, and note that while we set \Rcmd{AR.max} relatively high,
only and AR(6) model was fit significantly.

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, height=5, width=6.4, label=ARFIT>>=
atsar<-prewhiten(ats, AR.max=100, verbose=FALSE)
@
<<eval=TRUE, echo=TRUE, fig=TRUE, height=3, width=6.4, label=ARPSD>>=
plot(psdcore(atsar,ntaper=10), log="dB", main="PSD of MAGSAT innovations")
@
\caption{Top: Pre-whitening of a series assuming an AR model.
Bottom: Power spectral density estimates of the innovations (model residuals):
the spectrum is flat, as we would hope.}
\label{fig:magd}
\end{center}
\end{figure}

We didn't necessarily need to deal with the sampling information since it is just 1, 
but suppose the sampling information was based on an interval.
We can account for an interval 
by using a negative value for \Rcmd{X.frq}, 
with which \Rcmd{psdcore}
will interpret as
an interval (instead of a frequency). 
A quick example highlights the equivalency:
<<eval=TRUE, echo=TRUE>>=
a <- rnorm(32)
all.equal(psdcore(a,1)$spec, psdcore(a,-1)$spec)
@

Returning the the \Rcmd{RSEIS} comparison, we first 
estimate the PSD from \Rcmd{mtapspec} with 10 tapers:
<<eval=TRUE, echo=TRUE>>=
tapinit <- 10
Mspec <- mtapspec(ats, deltat(ats), MTP=list(kind=2, inorm=3, nwin=tapinit, npi=0))
str(Mspec)
@
where \Rcmd{nwin} is the number of tapers taken and
\Rcmd{npi} is, from the documentation, the ``number of Pi-prolate functions" (we
leave it out for the sake of comparison). 
Note that the object returned
is not of class \Rcmd{spec}.

Then we calculate the comparative spectra
from
\begin{enumerate}
  \item \Rcmd{spectrum} (20\% cosine taper),
  \item \Rcmd{psdcore} (with fixed tapers), and
  \item \Rcmd{pspectrum} (allowing adaptive taper refinement)
\end{enumerate}
We will need to correct for normalization factors, as necessary.

<<eval=TRUE, echo=TRUE>>=
Xspec <- spec.pgram(ats, pad=1, taper=0.2, detr=TRUE, dem=TRUE, plot=FALSE)
Pspec <- psdcore(ats, dt, tapinit)
Aspec <- pspectrum(ats, dt, tapinit, niter=3)
# Correct for double-sidedness of spectrum and mtapspec results
nt <- 1:Mspec$numfreqs
mspec <- Mspec$spec[nt] * 2
Xspec$spec <- 2 * Xspec$spec
@

An easy comparison is to plot them on the same scale, as shown in
Figure \ref{fig:psdcomp}.

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, label=fig_rseis>>=
require(RColorBrewer)
cols <- c("dark grey", brewer.pal(8, "Set1")[c(5:4,2)])
lwds <- c(1,2,2,5)
plot(Xspec, log="dB", ylim=40*c(-0.4,1), ci.col=NA, 
       col=cols[1], lwd=lwds[1], main="PSD comparisons") 
pltf <- Mspec$freq
lines(pltf, pltp <- dB(mspec), col=cols[2], lwd=lwds[2]) 
plot(Pspec, log="dB",  add=TRUE, col=cols[3], lwd=lwds[3]) 
plot(Aspec, log="dB", add=TRUE, col=cols[4], lwd=lwds[4]) 
legend("topright", 
            c("spec.pgram","mtapspec","psdcore","pspectrum"), 
            title="Estimator", lwd=3, cex=1.1, col=cols)
@
\caption{Comparisons of power spectral density estimators.}
\label{fig:psdcomp}
\end{center}
\end{figure}

Because we did not specify the length of the FFT in \Rcmd{mtapspec}
we end up with different length spectra.  So, to form some statistical measure
of the results, we need to interpolate PSD levels onto the \rlp{}-based frequencies:
<<eval=TRUE, echo=TRUE>>=
require(signal)
pltpi <- interp1(pltf, pltp, Pspec$freq)
@
We then regress the spectral values from \Rcmd{mtapspec} against
the \Rcmd{psdcore} results, since they both produced uniformly tapered spectra.
<<eval=TRUE, echo=TRUE>>=
df <- data.frame(x=dB(Pspec$spec), y=pltpi, tap=unclass(Aspec$taper))
summary(dflm <- lm(y ~ x + 0, df))
df$res <- residuals(dflm)
@
We create \Rcmd{ggplot2} objects for plotting purposes:
<<eval=TRUE, echo=TRUE>>=
require(ggplot2)
g1 <- ggplot(df, aes(x=x, y=y)) + 
    geom_abline(intercept=0, slope=1, size=2, color="salmon")+
    geom_point(aes(color=dB(y/x))) + 
    geom_smooth(colour="black", formula = y ~ x + 0, method="lm", 
                            se=TRUE, fullrange=TRUE) +
    scale_colour_gradient2(mid="light grey") +
    theme_bw() +
    ggtitle("Regression of mtapspec against psdcore")
g2 <- ggplot(df, aes(x=x, y=res)) + 
    geom_abline(intercept=0, slope=0, size=2, color="salmon") +
    geom_point(aes(color=tap)) +
    theme_bw() +
    ggtitle("Regression residuals, colored by optimized tapers")
@
The regression and residuals from these
objects are shown in Figure \ref{fig:psdreg}.  
The structure visible in the residuals
at low power levels appears to be from curvature bias in
the \Rcmd{mtapspec} results, which
manifests at short wavelengths
in Figure \ref{fig:psdcomp}.

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=FALSE, fig=TRUE, width=7, height=6, label=fig_rseis_vsRLP1>>=
print(g1)
@
<<eval=TRUE, echo=FALSE, fig=TRUE, width=7, height=3, label=fig_rseis_vsRLP2>>=
print(g2)
@
\caption{Regression of \Rcmd{mtapspec} PSD against \Rcmd{psdcore} PSD.}
\label{fig:psdreg}
\end{center}
\end{figure}

\subsection{\Rcmd{multitaper::spec.mtm}}
The function with the highest similarity to \rlp{} is
\Rcmd{spec.mtm} in the \Rcmd{multitaper} package.
This is not surprising since it calls 
source code of a Fortran equivalent to \rlp{}
authored by R.L. Parker (\citeyear{parkerweb}).
There are some notable differences, however.  
By default it uses the Discrete Prolate Spheroidal Sequences (dpss) 
of \citet{thomson1982},
which demand bandwidth tuning
there can be many more knobs to turn.

%BSM data?

\subsection{\Rcmd{SDF::sapa}}
As of this writing, the package has no maintainer; 
lest we end up discussing deprecated and archived functions,
we will not compare it to \rlp{}.

\section{Assessing spectral properties}
\subsection{Spectral uncertainties}
It is important to place bounds on the uncertainties associated
with a spectral estimate.
In a multitaper algorithm the uncertainty is distributed as
a $\chi{}_{\nu}^2$ variate where $\nu$ is
the number of degrees of freedom, which is twice the
number of tapers applied.
A proxy for this is simply $1/\sqrt{\nu - 1}$.
Using $\nu = 2*K$ we can approximate the distribution
of uncertainties from the tapers alone; however, a more
rigorous estimate comes from evaluating the appropriate 
distribution  for a coverage probability (e.g. $p=0.95$).
Among other calculations, \Rcmd{spectral\_properties} returns the 
$\chi{}_{\nu}^2$ based confidence intervals for $p=0.95$, as well as the
approximate uncertainties.  

To illustrate, we 
plot the uncertainties for an integer sequence\footnote{
Note the $\chi{}_{\nu}^2$ distribution is defined for non-negative,
non-integer degrees of freedom, but we cannot apply
fractions of tapers.} of tapers $[0, 50]$ in
Figure \ref{fig:psderr}.  The benefits of having more than just
a few tapers becomes obvious, though the spectral uncertainty
is asymptotically decreasing with taper numbers.

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, label=SPECERR>>=
sp <- spectral_properties(as.tapers(1:50), p=0.95, db.ci=TRUE)
plot(stderr.chi.upper ~ taper, sp, type="s", 
       ylim=c(-10,20), yaxs="i", xaxs="i",
       xlab=expression("number of tapers ("* nu/2 *")"), ylab="dB",
       main="Spectral uncertainties")
mtext("(additive factor)", line=.3)
lines(stderr.chi.lower ~ taper, sp, type="s")
lines(stderr.chi.median ~ taper, sp, type="s", lwd=2)
lines(stderr.chi.approx ~ taper, sp, type="s", col="red",lwd=2)
# to reach 3 db width confidence interval at p=.95
abline(v=33, lty=3)
legend("topright", c(expression("Based on "* chi^2 *"(p,"*nu*") and (1-p,"*nu*")"),
                               expression(""* chi^2 *"(p=0.5,"*nu*")"), "approximation"),
                               lwd=c(1,3,3), col=c("black","black","red"),
                               bg="white")
@
\caption{Spectral uncertainties by number of tapers, found
by forming the $\chi{}_{\nu}^2$ distribution, where $\nu$ is
the number of degrees of freedom (two per taper).  
The black lines show uncertainties for a coverage probability of 0.95.
The thick, red line shows an approximation to these uncertainties
based on $1/\sqrt{\nu}$, which is accurate to within a few percent.
}
\label{fig:psderr}
\end{center}
\end{figure}

Returning to the MAGSAT spectra, let us compare the \rlp{}
spectra with spectral uncertainty as bounded polygons.

First calculate the uncertainties:
<<eval=TRUE, echo=TRUE>>=
spp <- spectral_properties(Pspec$taper, db.ci=TRUE)
spa <- spectral_properties(Aspec$taper, db.ci=TRUE)
str(spa)
create_poly <- function(x, y, dy){
  xx <- c(x, rev(x))
  yy <- c(y+dy, rev(y-dy))
  return(data.frame(xx=xx, yy=yy))
}
pspp <- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.approx)
psppu <- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.upper)
pspa <- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.approx)
pspau <- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.upper)
@

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, width=7, height=6, label=MAGERR>>=
plot(c(0,0.5),c(-8,35),col="white", 
       main="MAGSAT Spectral Uncertainty (p > 0.95)",
       ylab="", xlab="spatial frequency, 1/km", yaxt="n", frame.plot=FALSE)
lines(c(2,1,1,2)*0.01,c(5,5,8.01,8.01)-8)
text(.05, -1.4, "3.01 dB")
polygon(psppu$xx, (psppu$yy), col="light grey", border="black", lwd=0.5)
polygon(pspp$xx, (pspp$yy), col="dark grey", border=NA)
text(0.15, 6, "With adaptive\ntaper refinement", cex=1.2)
polygon(pspau$xx, (pspau$yy)-10, col="light grey", border="black", lwd=0.5)
polygon(pspa$xx, (pspa$yy)-10, col="dark grey", border=NA)
text(0.35, 22, "Uniform tapering", cex=1.2)
@
\caption{Spectral uncertainties with and without adaptive taper optimization.}
\label{fig:magerr}
\end{center}
\end{figure}

\subsection{Spectral resolution}
There is an inherent tradeoff between the number of tapers 
applied and the spectral resolution (effectively, the spectral bandwidth).
In general the more tapers applied, the lower the spectral resolution.

We can use the return list from \Rcmd{spectral\_properties}
to visualize the differences in resolution for the MAGSAT estimates, as
in Figure \ref{fig:magres}.
\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=TRUE, fig=TRUE, width=7, height=4, label=MAGRES>>=
frq <- Aspec$freq
psd <- dB(Aspec$spec)
kopt <- unclass(Aspec$taper)
spres <- spa$resolution
pltdf <- data.frame(frq=frq, p=psd, relp=psd + dB(spres * frq), col="light grey")
pltdf$col[pltdf$relp<0] <- "light blue"
plot(relp ~ frq, pltdf, type="h",ylim=18*c(-1,1), col=pltdf$col, 
       xaxs="i", yaxs="i", main="MAGSAT Spectral Resolution",
       ylab="dB", xlab="spatial frequency, 1/km")
abline(h=0, lwd=1)
lines(relp ~ frq, pltdf, lwd=2)
@
\caption{Resolution limits for MAGSAT PSD (\Rcmd{niter=3} adapts).}
\label{fig:magres}
\end{center}
\end{figure}

\subsection{Visualizing the adaptive history}
One might be curious to study how the
uncertainties change with each iteration.
\Rcmd{pspectrum}
 saves an array of ``historical" data in its working environment.
 Specifically, it saves the frequencies,
 spectral values, and number of tapers at each stage of the adaptive
 procedure, accessible with \Rcmd{get\_adapt\_history}.

First we redo the spectral analysis to add a few more iterations to visualize,
and then bring the stage history into \Rcmd{.GlobalEnv}.
<<eval=TRUE, echo=TRUE>>=
pspectrum(ats, niter=6)
str(AH <- get_adapt_history())
@

% depending where the normalization occurs will determine
% the normalization of these! fix [ ]

<<eval=TRUE, echo=TRUE>>=
Freqs <- (AH$freq)
Dat <- AH$stg_psd
numd <- length(Freqs)
numit <- length(Dat)
StgPsd <- dB(matrix(unlist(Dat), ncol=numit))
Dat <- AH$stg_kopt
StgTap <- matrix(unlist(Dat), ncol=numit)
rm(Dat, AH)
@

% I think this is revealing a sequential normalization problem [ ]
We can plot these easily with \Rcmd{matplot}, and have done so in
Figure \ref{fig:psdhist}.  

\begin{figure}[htbp!]
\begin{center}
<<eval=TRUE, echo=FALSE, fig=TRUE, width=7, height=4, label=HIST1>>=
itseq <- 1:numit - 1
toadd <- matrix(rep(itseq, numd), ncol=numit, byrow=T)
par(xpd=TRUE)
sc <- 7
matplot(Freqs, StgPsd + sc*toadd, type="l", lty=1, lwd=2, col="black",
             main="PSD estimation history", ylab="", xlab="Spatial frequency",
             yaxt="n", frame.plot=FALSE)
text(0.51, 1.1*sc*itseq, itseq)
text(0.48, 1.1*sc*numit, "Stage:")
@
<<eval=TRUE, echo=FALSE, fig=TRUE, width=7, height=4, label=HIST2>>=
matplot(Freqs, StgTap, type="l", lty=itseq+1, lwd=2, col="black",
             main="Taper optimization history", ylab="", xlab="Spatial frequency",
             frame.plot=FALSE, ylim=c(-50,650), yaxs="i", bty="L")
par(xpd=TRUE)
legend(0.01, 730, paste("Stage", itseq), lwd=2, lty=itseq+1, ncol=4, bty="n")
@
\caption{Adaptive history.
Top: Sequential PSD series, offset by a few decibels for visualization purposes.
Bottom: Sequential taper series.
}
\label{fig:psdhist}
\end{center}
\end{figure}

%%
\pagebreak
\section{Call overview}

\begin{figure}[htbp!]
 \centering
 \includegraphics[width=0.6\textwidth]{yuml_d.png}%%
 \includegraphics[width=0.4\textwidth]{yuml_n.png}
 \caption{Simplified call graph for \rlp{}. The dashed lines show a
 simplified circuit
 in which the spectra and its tapers make during the iterative process.}
 \label{fig:calls}
\end{figure}

%%
\pagebreak
\bibliographystyle{apalike} %plainnat}
\bibliography{REFS}
\end{document}

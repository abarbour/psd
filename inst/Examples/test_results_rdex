
R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Confidence intervals from taper numbers
> ##
> sp <- spectral_properties(as.tapers(1:50), p=0.95, db.ci=TRUE)
> par(las=1)
> plot(stderr.chi.upper ~ taper, sp, type="s",
+        ylim=c(-10,20), yaxs="i", xaxs="i",
+        xlab=expression("number of tapers ("* nu/2 *")"), ylab="dB",
+        main="Spectral uncertainties")
> mtext("(additive factor)", line=.3)
> lines(stderr.chi.lower ~ taper, sp, type="s")
> lines(stderr.chi.median ~ taper, sp, type="s", lwd=2)
> lines(stderr.chi.approx ~ taper, sp, type="s", col="red",lwd=2)
> # to reach 3 db width confidence interval at p=.95
> abline(v=33, lty=3)
> legend("topright",
+         c(expression("Based on "* chi^2 *"(p,"*nu*") and (1-p,"*nu*")"),
+           expression(""* chi^2 *"(p=0.5,"*nu*")"),
+           "approximation"),
+ lwd=c(1,3,3), col=c("black","black","red"), bg="white")
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.329   0.025   0.347 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Taper constraint procedures
> ##
> data(magnet)
> X <- magnet$clean
> ##
> ## spectrum, then riedsid
> kopt <- riedsid(PSD <- psdcore(X, ntaper=10, refresh=TRUE))
Using spectral derivatives from  local quadratic regression
Constraining tapers with  ...  simple.slope  ...  method
> kopt.loess  <- riedsid(PSD, c.method="loess.smooth")
Using spectral derivatives from  local quadratic regression
Constraining tapers with  ...  loess.smooth  ...  method
> #
> plot(kopt, log="y", ylim =c(.1, 3e2))
> lines(kopt.loess, log="y", col="green")
Warning message:
In plot.xy(xy.coords(x, y), type = type, ...) :
  "log" is not a graphical parameter
> ##
> ##
> ## To compare all the methods at once:
> demo("ctap")


	demo(ctap)
	---- ~~~~

> ##
> ## Show usage of taper constaint procedures
> ##
> 
> # fake taper series
> set.seed(1234)

> nd <- 2e2

> x <- rnorm(nd, sd=10) + c(1:(nd/2),(nd/2 + 1):2)

> ntap <- as.tapers(rep(x,3))

> op <- par(no.readonly = TRUE)

> par(mfrow=c(1,4))

> ylim <- c(0,200)

> ## Raw tapers
> plot(ntap, ylim=ylim, main="Tapers: Raw")

> ## Constrained tapers:
> ## minspan
> plot(minspan(ntap), ylim=ylim, main="minspan")

> ## loess
> plot(ntap, ylim=ylim, main="loess") # OK, but a bit too smooth: reduce span

> lines(ctap_loess(ntap), col="green", lwd=2)

> lines(ctap_loess(ntap, loess.span=0.1), col="red", lwd=2)

> ## first difference
> plot(ntap, ylim=ylim, main="simple")

> lines(ctap_simple(ntap, maxslope=5), col="green", lwd=1) #resembles noise: use min slope (1, the default)

> lines(ctap_simple(ntap), col="red", lwd=2)

> par(op)
Warning messages:
1: In ctap_loess.tapers(ntap) :
  Generated a position sequence; results may be bogus.
2: In ctap_loess.tapers(ntap, loess.span = 0.1) :
  Generated a position sequence; results may be bogus.
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.461   0.029   0.492 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Normalization
> ##
> set.seed(1234)
> # timeseries with sampling frequency **not** equal to 1:
> X <- ts(rnorm(1e3), frequency=20)
> # spec.pgram: double sided
> pgram <- spectrum(X)
> # psdcore: single sided
> PSD <- psdcore(X)
> # note the normalization differences:
> plot(pgram, log="dB", ylim=c(-40,10))
> plot(PSD, add=TRUE, col="red", log="dB")
> # A crude representation of integrated spectrum: 
> #   should equal variance of white noise series (~= 1)
> mean(pgram$spec)*max(pgram$freq)
[1] 0.4913863
> mean(PSD$spec)*max(PSD$freq)
[1] 19.94124
> #
> # normalize objects with class 'spec'
> pgram <- normalize(pgram, src="spectrum")
Normalized  double-sided PSD  (SPECTRUM)  to single-sided PSD for sampling-freq.  1
> PSD <- normalize(pgram, src="psd")
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  1
> # replot them
> plot(pgram, log="dB", ylim=c(-40,10))
> plot(PSD, add=TRUE, col="red", log="dB")
> #
> # Again, integrated spectrum should be ~= 1:
> mean(pgram$spec)*max(pgram$freq)
[1] 0.9827725
> mean(PSD$spec)*max(PSD$freq)
[1] 0.9827725
> #
> ##----
> 
> proc.time()
   user  system elapsed 
  0.356   0.027   0.385 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Show parabolic weighting factors
> ##
> 
> ## some preliminaries
> require(grDevices)
> require(RColorBrewer)
Loading required package: RColorBrewer
> #
> maxx <- 1e3
> xseq <- c(5,maxx,seq(from=1,to=2.8,by=0.2))
> # plot palette
> pal <- "Spectral"
> npal <- switch(pal, RdYlBu=11, Spectral=11, Blues=9)
> pal.col <- RColorBrewer::brewer.pal(npal, pal)
> cols <- rev(grDevices::colorRampPalette(pal.col)(maxx))
> 
> ## a roundabout way of bootstrapping y-axis limits:
> WgtsU <- parabolic_weights_fast(xseq[1])
> xseq <- xseq[-1]
> DfU <- data.frame(matrix(unlist(WgtsU), ncol=2, byrow=FALSE))
> WgtsL <- parabolic_weights_fast(xseq[1])
> xseq <- xseq[-1]
> DfL <- data.frame(matrix(unlist(WgtsL), ncol=2, byrow=FALSE))
> # the limits:
> ylims <- round(dB(c(min(DfL$X2), max(DfU$X2))), 1) + c(-2,5)
> 
> # function for plotting text
> TFUN <- function(Df.){
+   tx <- max(Df.$X1)
+   ty <- mean(Df.$X2)
+   text(log10(tx)+0.1, dB(ty), sprintf("%i", tx), col=cols[tx])
+ }
> # function for weighting factors and plotting
> WFUN<-function(x){
+   message(x)
+   Wgts <- parabolic_weights_fast(x)
+   Df <- data.frame(matrix(unlist(Wgts), ncol=2, byrow=FALSE))
+   lcol <- cols[x]
+   lines(dB(X2) ~ log10(X1), Df, type="s", lwd=2, col=lcol)
+   TFUN(Df)
+ }
> 
> ## Plot parabolic weighting, in dB, colored by maximum num tapers
> plot(dB(X2) ~ log10(X1), DfU, type="s", xlim=c(0, log10(maxx)+0.2), 
+      col=cols[5], lwd=2, ylim=ylims, yaxs="i", 
+      main="Multitaper weighting factors by maximum tapers applied",
+      xlab="log10 taper sequence", 
+      ylab="dB")
> TFUN(DfU)
> invisible(lapply(round(10**xseq), FUN=WFUN))
10
16
25
40
63
100
158
251
398
631
> WFUN(maxx)
1000
> 
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.352   0.026   0.371 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Pilot spectrum
> ##
> data(magnet)
> ## simply calculate the pilot spectrum with a few tapers
> plot(pilot_spec(xc <-  magnet$clean), log="dB", 
+      main="Pilot PSDs for MAGNET and its AR-innovations (red)")
> ## remove the effect of an AR model works exceptionally
> ## well for the Project MAGNET data:
> plot(pilot_spec(xc, remove.AR=10), log="dB", add=TRUE, col="red")
> ##----
> 
> proc.time()
   user  system elapsed 
  0.489   0.030   0.513 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Using prewhiten to improve spectral estimates
> ##
> data(magnet)
> dx <- 1
> mts <- ts(magnet$clean, frequency=dx)
> mts.slope <- mts + seq_along(mts)
> # mean + trend
> # Prewhiten by removing mean+trend, and
> # AR model; fit truncates the series by 
> # a few terms, so zero pad
> mts <- prewhiten(mts.slope,  AR.max=10, zero.pad="rear")
detrending (and demeaning)
autoregressive model fit (returning innovations)
> mts.p <- mts$prew_lm
> mts.par <- mts$prew_ar
> #
> ntap <- 20
> ylog <- "dB"
> plot(PSD <- psdcore(mts.p, ntaper=ntap), log=ylog, lwd=2, ylim=c(-5,35))
> # remove the effect of AR model
> PSD.ar <- psdcore(mts.par, ntaper=ntap)
> PSD.ar$spec <- PSD.ar$spec / mean(PSD.ar$spec)
> PSD$spec <- PSD$spec / PSD.ar$spec
> plot(PSD, log=ylog, add=TRUE, lwd=2, col="red")
> plot(PSD.ar, log=ylog, add=TRUE, col="blue", lwd=2)
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.488   0.031   0.520 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Multitaper PSD estimation
> ##
> set.seed(1234)
> X <- rnorm(1e3)
> #
> # use the defaults, and appeal to plot.spec
> plot(psdcore(X))
> #
> # use more tapers, compare to stats::spectrum, and clear 
> # env data from the previous calculation
> psdcore(X, ntapers=10, plotpsd=TRUE, refresh=TRUE)
> #
> # change the sampling frequency to 20
> psdcore(X, 20, 10, plotpsd=TRUE, refresh=TRUE) 
> ##----
> 
> proc.time()
   user  system elapsed 
  0.434   0.028   0.463 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## psd working environment
> ##
> # Get some status information about the psd working environment
> psd_envStatus()
$env_name
[1] ".psdEnv"

$env_pointer
<environment: 0x7fa0ba959190>

$env_is_env
[1] TRUE

$listing
[1] "init"

$env_init
[1] "initialized upon attach"

$env_status_stamp
[1] "2014-10-16 14:55:40 PDT"

> #
> # Get a list of all variables
> psd_envList()
[1] "init"
> #
> # Pull the variable "init" into .GlobalEnv
> print(x <- psd_envGet("init"))
[1] "initialized upon attach"
> #
> # Pull the adaptive history into .GlobalEnv
> get_adapt_history()
NULL
Warning message:
In psd::psd_envGet("histlist") :
  Variable  'histlist'  not found! See psd_envList()
> ##----
> 
> proc.time()
   user  system elapsed 
  0.274   0.026   0.292 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> library(RColorBrewer)
> ##
> ## Adaptive multitaper PSD estimation
> ## (portions extracted from overview vignette)
> ## for the Project MAGNET dataset
> ##
> 
> data(magnet)
> 
> # adaptive psd estimation (turn off diagnostic plot)
> PSDr <- pspectrum(Xr <- magnet$raw, plot=FALSE)
Stage  0 est. (pilot) 
	environment  ** .psdEnv **  refreshed
detrending (and demeaning)
Stage  1 est. (Ave. S.V.R. -17.6 dB) 
Stage  2 est. (Ave. S.V.R. -34.3 dB) 
Stage  3 est. (Ave. S.V.R. -45.1 dB) 
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  1
> PSDc <- pspectrum(Xc <- magnet$clean, plot=FALSE)
Stage  0 est. (pilot) 
	environment  ** .psdEnv **  refreshed
detrending (and demeaning)
Stage  1 est. (Ave. S.V.R. -16.6 dB) 
Stage  2 est. (Ave. S.V.R. -35.1 dB) 
Stage  3 est. (Ave. S.V.R. -43.9 dB) 
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  1
> 
> # plot them on the same scale
> plot(PSDc, log="dB", main="Raw and Clean Project MAGNET power spectral density",
+      lwd=3, ci.col=NA, ylim=c(0,32), yaxs="i")
> plot(PSDr, log="dB", add=TRUE, lwd=3, lty=5)
> text(c(0.25,0.34), c(11,24), c("Clean","Raw"), cex=1)
> 
> ## Change sampling, and inspect the diagnostic plot
> pspectrum(Xc, niter=1, x.frqsamp=10)
Stage  0 est. (pilot) 
	environment  ** .psdEnv **  refreshed
detrending (and demeaning)
Stage  1 est. (Ave. S.V.R. -16.6 dB) 
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  10
> 
> ## Say we forgot to assign the results: we can recover from the environment with:
> PSDc_recovered <- psd:::psd_envGet("final_psd")
> plot(PSDc_recovered)
> 
> ##
> ## Visualize adaptive history
> ##
> ## Previous adaptive estimation history
> pspectrum(Xc, niter=6, plot=FALSE)
Stage  0 est. (pilot) 
	environment  ** .psdEnv **  refreshed
detrending (and demeaning)
Stage  1 est. (Ave. S.V.R. -16.6 dB) 
Stage  2 est. (Ave. S.V.R. -35.1 dB) 
Stage  3 est. (Ave. S.V.R. -43.9 dB) 
Stage  4 est. (Ave. S.V.R. -45.0 dB) 
Stage  5 est. (Ave. S.V.R. -45.0 dB) 
Stage  6 est. (Ave. S.V.R. -45.7 dB) 
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  1
> AH <- get_adapt_history()
> Freqs <- (AH$freq)
> Dat <- AH$stg_psd
> numd <- length(Freqs)
> numit <- length(Dat)
> StgPsd <- dB(matrix(unlist(Dat), ncol=numit))
> Dat <- AH$stg_kopt
> StgTap <- matrix(unlist(Dat), ncol=numit)
> rm(Dat, AH)
> 
> ## plot psd history
> seqcols <- 1:numit
> itseq <- seqcols - 1
> toadd <- matrix(rep(itseq, numd), ncol=numit, byrow=TRUE)
> par(xpd=TRUE)
> matplot(Freqs, StgPsd + (sc<-9)*toadd, type="l", lty=1, lwd=2, col="black",
+              main="PSD estimation history", ylab="", xlab="Spatial frequency",
+              yaxt="n", frame.plot=FALSE)
> text(.52, 1.05*sc*itseq, itseq)
> text(.49, 1.1*sc*numit, "Stage:")
> 
> ## plot taper history "mountain range" silhouettes
> par(xpd=TRUE)
> Cols <- rev(rev(brewer.pal(9, "PuBuGn"))[seqcols])
> invisible(lapply(rev(seqcols), FUN=function(mcol, niter=numit, Frq=Freqs, Dat=StgTap, cols=Cols){
+   iter <- (niter+1)-mcol
+   y <- Dat[,mcol]
+   icol <- Cols[mcol]
+   if (iter==1){
+     plot(Frq, y, type="h", col=icol,
+            main="Taper optimization history", ylab="", xlab="Spatial frequency",
+            ylim=c(-50,650), frame.plot=FALSE)
+   } else {
+     lines(Frq, y, type="h", col=icol)
+   }
+   lines(Frq, y, type="l",  lwd=1.2)
+   x <- (c(0,1)+iter-1)*.05+0.075
+   y <- c(595,595,650,650,595)+10
+   text(mean(x),max(y)+1.0*diff(range(y)), mcol-1)
+   polygon(c(x,rev(x),x[1]),y,border="black",col=icol)
+ }
+ )) # end of invisible lapply
> ##----
> 
> proc.time()
   user  system elapsed 
  1.544   0.047   1.601 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Riedel-Sidorenko--Parker taper optimization
> ##
> set.seed(1234)
> # some params
> nd <- 512 # num data
> ntap <- 10 # num tapers
> nrm <- 40 # sharpness of the peaks rel 2*variance
> #
> # create a pseudo spectrum
> # with broad peaks
> riex <- rnorm(nd) + nrm*abs(cos(pi*(x<-0:(nd-1))/180) + 1.2)
> riex <- riex + 8*nrm*dcauchy(x, nd/3)
> riex <- riex + 5*nrm*dnorm(x, nd/2)
> # flat regions
> riex[riex<25] <- 25
> ried <- dB(riex, invert=TRUE)
> #
> # optimize tapers
> rtap <- riedsid(riex, ntaper=ntap)
Using spectral derivatives from  local quadratic regression
Constraining tapers with  ...  simple.slope  ...  method
> #
> # plot
> op <- par(no.readonly = TRUE)
> par(mfrow=c(2,1), mar=rep(1.3,4), mai=rep(0.6,4))
> # ... the mock spectrum
> plot(riex, type="h", xaxs="i", ylim=c(0,200)) 
> # ... the optimal tapers
> plot(rtap, log="y") 
> # original tapers:
> lines(as.tapers(rep.int(ntap,nd)), col="blue")
> par(op)
> ##----
> 
> proc.time()
   user  system elapsed 
  0.336   0.025   0.355 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Objects with class 'spec'
> ##
> set.seed(1234)
> #
> x <- spectrum(xn<-rnorm(10), plot=FALSE)
> xdf <-as.data.frame(x)
> str(xdf)
'data.frame':	5 obs. of  3 variables:
 $ freq : num  0.1 0.2 0.3 0.4 0.5
 $ spec : num  0.0659 0.569 2.2866 1.3247 0.6083
 $ taper: num  0.1 0.1 0.1 0.1 0.1
 - attr(*, "df")= num 1.79
 - attr(*, "bandwidth")= num 0.0289
 - attr(*, "n.used")= int 10
 - attr(*, "orig.n")= int 10
 - attr(*, "series")= chr "x"
 - attr(*, "method")= chr "Raw Periodogram"
 - attr(*, "pad")= num 0
 - attr(*, "detrend")= logi TRUE
 - attr(*, "demean")= logi FALSE
> is.tapers(xdf$taper)
[1] FALSE
> #
> # tapers class is retained
> #
> x <- psdcore(xn)
> xdf <- as.data.frame(x)
> str(xdf)
'data.frame':	6 obs. of  3 variables:
 $ freq : num  0 0.1 0.2 0.3 0.4 0.5
 $ spec : num  0.013 0.149 1.705 4.023 2.904 ...
 $ taper:Class 'tapers'  atomic [1:6] 1 1 1 1 1 1
  .. ..- attr(*, "n_taper_limits")= num [1:2] 1 1.4
  .. ..- attr(*, "taper_positions")= logi NA
  .. ..- attr(*, "span_was_set")= logi TRUE
  .. ..- attr(*, "n_taper_limits_orig")= num [1:2] 1 1
 - attr(*, "df")= num 2
 - attr(*, "bandwidth")= num 0.4
 - attr(*, "n.used")= num 10
 - attr(*, "orig.n")= int 10
 - attr(*, "series")= chr "xn"
 - attr(*, "method")= chr "Sine multitaper\npsdcore (dem.+detr. TRUE f.l. TRUE refr. FALSE)"
 - attr(*, "pad")= num 1
 - attr(*, "detrend")= logi TRUE
 - attr(*, "demean")= logi TRUE
> is.tapers(xdf$taper)
[1] TRUE
> ##----
> 
> proc.time()
   user  system elapsed 
  0.311   0.026   0.330 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Spectral properties from the number of tapers used
> ## (portions extracted from overview vignette)
> ##
> 
> ##
> ## Theoretical uncertainties from Chi^2 distribution
> ##
> sp <- spectral_properties(as.tapers(1:50), p=0.95, db.ci=TRUE)
> par(las=1)
> plot(stderr.chi.upper ~ taper, sp, type="s",
+        ylim=c(-10,20), yaxs="i", xaxs="i",
+        xlab=expression("number of tapers ("* nu/2 *")"), ylab="dB",
+        main="Spectral uncertainties")
> mtext("(additive factor)", line=.3)
> lines(stderr.chi.lower ~ taper, sp, type="s")
> lines(stderr.chi.median ~ taper, sp, type="s", lwd=2)
> lines(stderr.chi.approx ~ taper, sp, type="s", col="red",lwd=2)
> # to reach 3 db width confidence interval at p=.95
> abline(v=33, lty=3)
> legend("topright",
+         c(expression("Based on "* chi^2 *"(p,"*nu*") and (1-p,"*nu*")"),
+           expression(""* chi^2 *"(p=0.5,"*nu*")"),
+           "approximation"),
+ lwd=c(1,3,3), col=c("black","black","red"), bg="white")
> 
> ##
> ## An example using the Project MAGNET dataset
> ##
> data(magnet)
> tapinit <- 15 # tapers
> dt <- 1 # 1/km
> 
> # remove mean/trend (not really necessary but good practice; also, done internally)
> ats <- prewhiten(ts(magnet$clean, deltat=dt), plot=FALSE)$prew_lm
detrending (and demeaning)
> 
> # normal and adaptive multitaper spectra
> Pspec <- psdcore(ats, dt, tapinit)
> Aspec <- pspectrum(ats, dt, tapinit, niter=3, plot=FALSE)
Stage  0 est. (pilot) 
	environment  ** .psdEnv **  refreshed
detrending (and demeaning)
Stage  1 est. (Ave. S.V.R. -20.3 dB) 
Stage  2 est. (Ave. S.V.R. -30.1 dB) 
Stage  3 est. (Ave. S.V.R. -30.5 dB) 
Normalized  single-sided PSD  (PSD)  to single-sided PSD for sampling-freq.  1
> 
> # calculate spectral properties
> spp <- spectral_properties(Pspec$taper, db.ci=TRUE)
> spa <- spectral_properties(Aspec$taper, db.ci=TRUE)
> 
> # function to create polygon data, and create them
> create_poly <- function(x, y, dy){
+   xx <- c(x, rev(x))
+   yy <- c(y+dy, rev(y-dy))
+   return(data.frame(xx=xx, yy=yy))
+ }
> pspp <- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.approx)
> psppu <- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.upper)
> pspa <- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.approx)
> pspau <- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.upper)
> 
> ##
> ## Project MAGNET uncertainties
> ##
> plot(c(0,0.5),c(-8,35),col="white",
+        main="Project MAGNET Spectral Uncertainty (p > 0.95)",
+        ylab="", xlab="spatial frequency, 1/km", yaxt="n", frame.plot=FALSE)
> lines(c(2,1,1,2)*0.01,c(5,5,8.01,8.01)-8)
> text(.05, -1.4, "3.01 dB")
> polygon(psppu$xx, (psppu$yy), col="light grey", border="black", lwd=0.5)
> polygon(pspp$xx, (pspp$yy), col="dark grey", border=NA)
> text(0.15, 6, "With adaptive\ntaper refinement", cex=1.2)
> polygon(pspau$xx, (pspau$yy)-10, col="light grey", border="black", lwd=0.5)
> polygon(pspa$xx, (pspa$yy)-10, col="dark grey", border=NA)
> text(0.35, 22, "Uniform tapering", cex=1.2)
> 
> ##
> ## Project MAGNET resolution
> ##
> frq <- Aspec$freq
> relp <- dB(1/spa$resolution)
> par(las=1)
> plot(frq, relp,
+      col="light grey",
+      ylim=dB(c(1,5)),
+      type="h", xaxs="i", yaxs="i",
+      ylab="dB", xlab="frequency, 1/km",
+      main="Project MAGNET Spectral Resolution and Uncertainty")
> lines(frq, relp)
> lines(frq, spp$stderr.chi.upper+relp, lwd=1.5, lty=3)
> lines(frq, spa$stderr.chi.upper+relp, lwd=3, lty=2)
> abline(h=dB(sqrt(vardiff(Aspec$spec))), lwd=1.5, lty=2, col="red")
> 
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.722   0.036   0.760 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Spline gradient
> ##
> set.seed(1234)
> x <- seq(0,5*pi,by=pi/64)
> y <- cos(x) #**2
> splineGrad(x, y, TRUE)
> y <- y + rnorm(length(y), sd=.1)
> # unfortunately, the presence of
> # noise will affect numerical derivatives
> splineGrad(x, y, TRUE)
> # so change the smoothing used in smooth.spline
> splineGrad(x, y, TRUE, spar=0.2)
> splineGrad(x, y, TRUE, spar=0.6)
> splineGrad(x, y, TRUE, spar=1.0)
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.372   0.028   0.402 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Objects with class 'tapers'
> ##
> is.tapers(as.tapers(1))
[1] TRUE
> is.tapers(as.tapers(1:10))
[1] TRUE
> is.tapers(as.tapers(matrix(1:10,ncol=1)))
[1] TRUE
> as.tapers(list(x=1:10,y=1:30)) # note dimensions
'tapers' object: num. tapers applied by index
	head:  1 2 3 4 5 6
		...
	tail:  25 26 27 28 29 30
> as.tapers(x<-data.frame(x=1:10,y=10:19))
'tapers' object: num. tapers applied by index
	head:  1 2 3 4 5 6
		...
	tail:  14 15 16 17 18 19
> as.tapers(x, min_taper=3, max_taper=10)
'tapers' object: num. tapers applied by index
	head:  3 3 3 4 5 6
		...
	tail:  10 10 10 10 10 10
> # class 'character' is in-coercible; raise error
> try(as.tapers(c("a","b")), silent=TRUE)
> ##----
> 
> proc.time()
   user  system elapsed 
  0.270   0.025   0.288 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##----
> library(psd)
Loading required package: fftw
Loaded psd (0.4.3) -- Adaptive multitaper spectrum estimation.
> ##
> ## Various utilities
> ##
> set.seed(1234)
> X <- rnorm(1e2)
> ##
> ## Matrix and vector creation:
> ##
> # NA matrix
> nd <- 5
> na_mat(nd)
     [,1]
[1,]   NA
[2,]   NA
[3,]   NA
[4,]   NA
[5,]   NA
> na_mat(nd,nd-1)
     [,1] [,2] [,3] [,4]
[1,]   NA   NA   NA   NA
[2,]   NA   NA   NA   NA
[3,]   NA   NA   NA   NA
[4,]   NA   NA   NA   NA
[5,]   NA   NA   NA   NA
> # zeros
> zeros(nd)
     [,1]
[1,]    0
[2,]    0
[3,]    0
[4,]    0
[5,]    0
> # and ones
> ones(nd)
     [,1]
[1,]    1
[2,]    1
[3,]    1
[4,]    1
[5,]    1
> ##
> ## Check for tapers object:
> ##
> is.tapers(X)
[1] FALSE
> is.tapers(as.tapers(X))
[1] TRUE
> ##
> ## Check for spec object:
> ##
> PSD <- spectrum(X, plot=FALSE)
> plot(PSD)
> # return is class 'spec'
> is.spec(PSD) # TRUE
[1] TRUE
> # but the underlying structure is just a list
> PSD <- unclass(PSD)
> is.spec(PSD) # FALSE
[1] FALSE
> ##
> ## Environment character strings
> ##
> print(envname <- get_psd_env_name())
[1] ".psdEnv"
> print(envir <- char2envir(envname))
<environment: 0x7ff31c959190>
> try(char2envir("some nonexistent environment"), silent=TRUE) # error
> # and environment objects:
> print(.GlobalEnv)
<environment: R_GlobalEnv>
> envir2char(.GlobalEnv)
[1] ".GlobalEnv"
> envir2char(envir)
[1] "envir"
> try(envir2char(some_nonexistent_environment), silent=TRUE) # error
> ##
> ## decibels
> ##
> dB(1) # signal is equal <--> zero dB
[1] 0
> sig <- 1e-10
> all.equal(sig, dB(dB(sig), invert=TRUE))
[1] TRUE
> pow <- sig**2
> all.equal(pow, dB(dB(sig, is.power=TRUE), invert=TRUE, is.power=TRUE))
[1] TRUE
> ## 
> ## Variance of difference series
> ##
> vardiff(X)
[1] 1.708794
> varddiff(X)
[1] 4.948977
> all.equal(vardiff(X, TRUE), varddiff(X))
[1] TRUE
> ##
> ## modulo division
> ##
> x <- 1:10
> mc1a <- mod(1,2)
> mc2a <- mod(1+x,2)
> mc1b <- 1 %% 2
> mc2b <- 1 + x %% 2
> mc2c <- (1 + x) %% 2
> all.equal(mc1a, mc1b) # TRUE
[1] TRUE
> all.equal(mc2a, mc2b) # "Mean absolute difference: 2"
[1] "Mean absolute difference: 2"
> all.equal(mc2a, mc2c) # TRUE
[1] TRUE
> ##
> ##----
> 
> proc.time()
   user  system elapsed 
  0.326   0.025   0.345 
